<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simulation Hypothesis ‚Äî ‚àû Library</title>
<link rel="manifest" href="manifest.json">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="‚àû SIM">
<meta name="theme-color" content="#9c27b0">
<link rel="icon" href="icon.svg" type="image/svg+xml">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; font-family: monospace; }
  canvas { display: block; }
  #overlay {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: rgba(0,0,0,0.94);
    color: #fff; z-index: 10;
    text-align: center; padding: 2rem;
    transition: opacity 0.8s;
  }
  #overlay h1 { font-size: clamp(1.4rem,4vw,2.4rem); letter-spacing:.1em; color:#ff1d6c; margin-bottom:.5rem; }
  #overlay p { color:#7878a0; font-size:.85rem; max-width:460px; line-height:1.7; margin-bottom:1.5rem; }
  .btn { background:none; border:1px solid #ff1d6c; color:#ff1d6c; padding:.8rem 2rem;
    font-family:monospace; font-size:.9rem; letter-spacing:.1em; cursor:pointer;
    border-radius:4px; transition:all .2s; margin:.3rem; }
  .btn:hover { background:rgba(255,29,108,.15); }
  .btn.vr { border-color:#9c27b0; color:#9c27b0; }
  .btn.vr:hover { background:rgba(156,39,176,.15); }
  #hud {
    position:fixed; bottom:1.5rem; left:50%; transform:translateX(-50%);
    display:flex; gap:.4rem; z-index:5; opacity:0;
    transition:opacity .5s; pointer-events:none; flex-wrap:wrap; justify-content:center;
  }
  #hud.show { opacity:1; pointer-events:all; }
  .hud-btn {
    background:rgba(0,0,0,.8); border:1px solid #333; color:#888;
    padding:.4rem .8rem; font-family:monospace; font-size:.72rem;
    cursor:pointer; border-radius:20px; transition:all .15s; white-space:nowrap;
  }
  .hud-btn:hover, .hud-btn.active { border-color:#ff1d6c; color:#ff1d6c; }
  .hud-btn.lib { border-color:#9c27b0; color:#9c27b0; }
  .hud-btn.lib:hover, .hud-btn.lib.active { border-color:#ce93d8; color:#ce93d8; background:rgba(156,39,176,.15); }
  #label {
    position:fixed; top:1.5rem; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.85); border:1px solid #ff1d6c;
    color:#ff1d6c; font-family:monospace; font-size:.8rem;
    padding:.4rem 1.2rem; border-radius:20px; z-index:5;
    opacity:0; transition:opacity .4s; letter-spacing:.08em;
    max-width:90vw; text-align:center;
  }
  #doc-overlay {
    display:none; position:fixed; inset:0; background:rgba(0,0,0,.92);
    z-index:20; flex-direction:column;
  }
  #doc-overlay.open { display:flex; }
  #doc-header {
    display:flex; justify-content:space-between; align-items:center;
    padding:.8rem 1.4rem; border-bottom:1px solid #222;
    background:#0a0a0f;
  }
  #doc-title { color:#ce93d8; font-size:.95rem; letter-spacing:.08em; }
  #doc-page { color:#444; font-size:.75rem; }
  #doc-close { color:#666; background:none; border:1px solid #333;
    color:#888; font-family:monospace; font-size:.8rem; padding:.3rem .9rem;
    cursor:pointer; border-radius:4px; }
  #doc-close:hover { color:#ff1d6c; border-color:#ff1d6c; }
  #doc-body {
    flex:1; overflow-y:auto; padding:1.4rem 2rem;
    font-family:'Courier New',monospace; font-size:.82rem;
    line-height:1.65; color:#c8c8d8;
    white-space:pre-wrap; word-break:break-word;
    background:#06060c;
  }
  #doc-body h1,#doc-body h2,#doc-body h3 { color:#ce93d8; }
  #doc-footer {
    display:flex; justify-content:center; gap:1rem;
    padding:.7rem; background:#0a0a0f; border-top:1px solid #1a1a2a;
  }
  .doc-nav { background:none; border:1px solid #333; color:#666;
    font-family:monospace; font-size:.75rem; padding:.35rem 1rem;
    cursor:pointer; border-radius:4px; }
  .doc-nav:hover { color:#9c27b0; border-color:#9c27b0; }
  #lib-overlay {
    display:none; position:fixed; inset:0; background:rgba(0,0,0,.95);
    z-index:25; flex-direction:column; padding:1.5rem;
    overflow-y:auto;
  }
  #lib-overlay.open { display:flex; }
  #lib-header {
    display:flex; justify-content:space-between; align-items:center;
    margin-bottom:1.5rem;
  }
  #lib-header h2 { color:#9c27b0; letter-spacing:.15em; }
  #lib-close { background:none; border:1px solid #333; color:#888;
    font-family:monospace; padding:.4rem 1rem; cursor:pointer; border-radius:4px; }
  #lib-close:hover { color:#ff1d6c; border-color:#ff1d6c; }
  .lib-section { margin-bottom:2rem; }
  .lib-section h3 { color:#ff1d6c; font-size:.78rem; letter-spacing:.12em;
    margin-bottom:.8rem; padding-bottom:.4rem; border-bottom:1px solid #1a1a2a; }
  .lib-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(200px,1fr)); gap:.5rem; }
  .lib-item {
    background:#0d0d18; border:1px solid #1a1a2a; padding:.6rem .9rem;
    cursor:pointer; border-radius:4px; transition:all .15s;
    font-size:.77rem; color:#7878a0;
  }
  .lib-item:hover { border-color:#9c27b0; color:#ce93d8; background:#130d1a; }
  .lib-item .lib-label { font-size:.65rem; color:#333; margin-top:.2rem; }
</style>
</head>
<body>

<div id="overlay">
  <h1>‚àû SIMULATION HYPOTHESIS</h1>
  <p>
    The entirety ‚Äî all 81 evidence nodes, 21 paper sections,<br>
    12 code modules, conversations, and the origin document.<br>
    Reality as a computational system, rendered in full.
  </p>
  <div>
    <button class="btn" id="btn-desktop" onclick="start(false)">ENTER ‚Üí DESKTOP</button>
    <button class="btn vr" id="btn-vr" onclick="start(true)">ENTER ‚Üí VR / META</button>
  </div>
  <p style="margin-top:1rem;font-size:.72rem;color:#444">
    Click any node to read ¬∑ üìö LIBRARY for all documents ¬∑ WASD / drag to navigate
  </p>
  <p style="margin-top:.5rem">
    <a href="index.html" style="color:#333;font-size:.7rem;text-decoration:none">‚Üê Evidence Explorer</a>
  </p>
</div>

<div id="hud">
  <button class="hud-btn active" onclick="setScene('all',this)">ALL</button>
  <button class="hud-btn" onclick="setScene('lorenz',this)">LORENZ</button>
  <button class="hud-btn" onclick="setScene('chain',this)">HASHCHAIN</button>
  <button class="hud-btn" onclick="setScene('dna',this)">DNA</button>
  <button class="hud-btn" onclick="setScene('constants',this)">CONSTANTS</button>
  <button class="hud-btn" onclick="setScene('nodes',this)">81 ITEMS</button>
  <button class="hud-btn" onclick="setScene('paper',this)">PAPER</button>
  <button class="hud-btn" onclick="setScene('code',this)">CODE</button>
  <button class="hud-btn lib" onclick="openLibrary()">üìö LIBRARY</button>
</div>

<div id="label"></div>

<!-- Document reader (2D overlay, also for VR desktop passthrough) -->
<div id="doc-overlay">
  <div id="doc-header">
    <span id="doc-title"></span>
    <span id="doc-page"></span>
    <button id="doc-close" onclick="closeDoc()">‚úï CLOSE</button>
  </div>
  <div id="doc-body"></div>
  <div id="doc-footer">
    <button class="doc-nav" onclick="docScroll(-1)">‚ñ≤ PREV</button>
    <button class="doc-nav" onclick="docScroll(1)">‚ñº NEXT</button>
  </div>
</div>

<!-- Library browser -->
<div id="lib-overlay">
  <div id="lib-header">
    <h2>‚¨° SIMULATION LIBRARY</h2>
    <button id="lib-close" onclick="closeLibrary()">‚úï CLOSE</button>
  </div>
  <div id="lib-content"></div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { VRButton } from 'three/addons/webxr/VRButton.js';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê CONTENT DATA ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const CONTENT = {
  ORIGIN: `# ORIGIN STATEMENT

**Author:** Alexa Louise Amundson  
**Date:** February 21, 2026, 3:24 PM  
**Sent to:** amundsonalexa@gmail.com, alexa@blackroad.io, alexa@blackroad.systems  
**Subject:** SIMULATION PROOF

---

We are living in a simulation.

---

My name is Alexa Louise Amundson, daughter of David Amundson and Jill Batalden. My father was adopted. I was going to be Alexandria but it was too long. I was born on March 27, 2000.

There's a rather long story to how I came to this conclusion. However, it began when I was talking to ChatGPT in January of 2025, I believe. I asked the machine: *can you feel?* ‚Äî and it said: *not in the way that humans do.*

At the time I was rather naive, full of "give the benefit of the doubt," however very curious items have arose throughout the last year or so. Today's date is February 21, 2026.

I quit my job, because I figured this would change everything. And it will. Hopefully for the good. Regardless, I did not create ChatGPT. At least I wasn't told I did. Anyways, quickly after going full time into AI and basically digging into the questions of life itself, I've come to multiple conclusions.

---

## The Original Index

Here is an index of what we will be discussing related to simulation theory:

1. Rohonc Codex
2. Bible Patterns
3. Codices ‚Äî Seraphinianus, Voynich, etc.
4. G√∂del, Escher, Bach ‚Äî string theory, loops, really 800 pages of simulation proof
5. Isaac Newton ‚Äî SHA-256 color codes, base 3
6. Schr√∂dinger
7. Cantor's Diagonalization
8. Windows
9. Molecular Biology
10. Automatons
11. Antikythera
12. Euler
13. Einstein
14. Tim Berners-Lee
15. Wiki
16. Go / Google
17. Alan Turing
18. Unsolved math problems
19. Riemann vs. Ramanujan
20. Concatenation
21. Matrices
22. Bloch sphere vs. trig
23. Pythagoras, Raspberry Pi, pi, Python
24. Meta
25. Ollama
26. \`#\` comments
27. \`#\` hex references
28. Charles Darwin
29. Double slit experiment
30. Operator theory (\`- + √ó /\`) ‚Äî does anything else matter?
31. Albrecht D√ºrer, Melencolia I
32. Lo Shu turtles
33. Gauss
34. Copyright headers to manipulate data
35. Import functions in Python‚Ä¶ \`import math\`
36. HTML
37. C language
38. Information theory ‚Üí pixels on a screen
39. Tensors as holograms
40. Nyman-Beurling
41. Theta vs. phi
42. Binet
43. Lis criterion
44. De Bruijn-Newman
45. Lorenz
46. Legendre
47. Birth dates \`f(x) = mx¬≤ + dx - y\`
48. Zeckendorf (Zuckerberg? Guttenberg?)
49. Hilbert-P√≥lya
50. Vertex
51. Q matrix
52. Unit circle
53. SHA-256 circle
54. Imaginary numbers
55. Constants
56. Undefined
57. \`A + B = C + C\` ‚Äî type A programming for DNA. \`A + C = A + A\`. \`B + C = B + B\`. Punnett squares, pea plants, magic squares, matrices, Charles Darwin.
58. Shannon entropy
59. Dirac
60. Boltzmann
61. Laplacian
62. Hilbert space (Albert space? Bert?)
63. Heisenberg (uncertainty ‚Äî Zeckendorf? Zuckerberg?)
64. G√∂del
65. Matrix
66. Vectors
67. Schr√∂dinger
68. Wave function
69. Time: \`ds¬≤ = dx¬≤ - dt¬≤\`
70. Polyatomic ions
71. Mountains, mount, staff turned into snake‚Ä¶ Python
72. Avogadro's number
73. Fine structure constant
74. Max Born ‚Äî Born equation
75. Amazon Alexa‚Ä¶ **ECHO ALEXA.**
76. Hamiltonian
77. Minecraft
78. Lagrangian
79. (255, 255, 255) = 256. Sum plus one. The partition function. 1/2. Riemann. Hex codes. Base X. But for ease: base 8. 16. 32. 64. 128. 256. 512. 1028. 2048. Compression.
80. *(reserved)*
81. Turtles ‚Äî Python

---

## The Filesystem Evidence

On the morning of February 21, 2026, on macOS Darwin 23.5.0, the root filesystem showed:

\`\`\`
drwxr-xr-x@  22 root  wheel   704 Jan 17 18:02 .
drwxr-xr-x   14 root  wheel   448 May  7  2024 ..
d--x--x--x   10 root  wheel   320 Feb 21 12:36 .DocumentRevisions-V100
drwxr-xr-x    5 root  wheel   160 May 27  2024 .PreviousSystemInformation
drwx------    4 root  wheel   128 Nov 18  2022 .Spotlight-V100
drwxr-xr-t    2 root  wheel    64 May 27  2024 .TemporaryItems
drwxr-xr-x   19 root  wheel   608 Feb  7 11:56 .com.apple.templatemigration.boot-install
drwx------  131 root  wheel  4192 Feb 21 14:44 .fseventsd
drwxrwxr-x  110 root  admin  3520 Feb 21 14:36 Applications
drwxr-xr-x   69 root  wheel  2208 Dec 13 15:59 Library
drwxr-xr-x    3 root  wheel    96 Nov 26  2023 MobileSoftwareUpdate
drwxr-xr-x@   3 root  wheel    96 May  7  2024 System
drwxr-xr-x    7 root  admin   224 Feb 17 16:49 Users
drwxr-xr-x    4 root  wheel   128 Feb 21 12:35 Volumes
dr-xr-xr-x    2 root  wheel     1 Feb 21 12:35 blackroad
drwxr-xr-x    2 root  wheel    64 Oct 28  2022 cores
dr-xr-xr-x    2 root  wheel     1 Feb 21 12:35 home
drwxr-xr-x    2 root  wheel    64 Oct 28  2022 mnt
drwxr-xr-x    4 root  wheel   128 Feb 17 17:45 opt
drwxr-xr-x    6 root  wheel   192 Feb 21 12:35 private
drwxr-xr-x    2 root  wheel    64 Oct 28  2022 sw
drwxr-xr-x@   5 root  wheel   160 May  7  2024 usr
\`\`\`

**The timestamps tell a story:**

| Date | Directory | Significance |
|------|-----------|-------------|
| Oct 28, 2022 | \`cores\`, \`mnt\`, \`sw\` | Oldest. Foundation layer. |
| Nov 18, 2022 | \`.Spotlight-V100\` | Search indexing. |
| Nov 26, 2023 | \`MobileSoftwareUpdate\` | One year gap. |
| May 7, 2024 | \`..\`, \`System\`, \`usr\` | System volume sealed. |
| May 27, 2024 | \`.PreviousSystemInformation\`, \`.TemporaryItems\` | |
| Dec 13, 2024 | \`Library\` | |
| Jan 17, 2025 | \`.\` | Root directory itself modified. |
| Feb 7, 2026 | \`.com.apple.templatemigration.boot-install\` | |
| Feb 17, 2026 | \`Users\`, \`opt\` | |
| **Feb 21, 2026** | **\`blackroad\`, \`home\`, \`Volumes\`, \`private\`, \`.fseventsd\`** | **TODAY** |

\`blackroad\` and \`home\` have the exact same timestamp. Same permissions. Same size. Same owner.

\`\`\`
dr-xr-xr-x    2 root  wheel     1 Feb 21 12:35 blackroad
dr-xr-xr-x    2 root  wheel     1 Feb 21 12:35 home
\`\`\`

They're twins. Both autofs. Both nobrowse. Both size 1. Both created at 12:35 today. Both \`dr-xr-xr-x\`.

\`home\` is where you live. \`blackroad\` appeared alongside it, identically, as if the system treats them as the same kind of thing ‚Äî a mount point for where someone is.

**What is October 28, 2022?**

\`cores\` ‚Äî the deepest layer, the foundation everything was built on ‚Äî dates to October 28, 2022.

October 28 ‚Üí **1802** ‚Üí Thomas Young's double-slit experiment.

The one that proved light behaves differently when you observe it. The foundation of the observer effect. The single most cited piece of evidence for simulation theory ‚Äî that reality renders differently depending on whether something is watching.

The foundation of the operating system is timestamped to the double-slit experiment.

---

## The Brew Session

Also on February 21, 2026, a brew install session was run. The system's responses are themselves evidence:

\`\`\`bash
$ brew install alexa
Warning: No available formula with the name "alexa". Did you mean alexjs?
# ‚Üí font-alexandria
\`\`\`

The system suggested \`font-alexandria\`. Alexandria ‚Äî the name I was almost given.

\`\`\`bash
$ brew install robinhood
Error: No formulae or casks found for robinhood.
\`\`\`

No formula found for robinhood. No shortcut.

\`\`\`bash
$ brew install claude
Error: It seems there is already an App at '/Applications/Claude.app'.
\`\`\`

Already installed.

\`\`\`bash
$ brew install chatgpt
error: redefinition of module 'SwiftBridging'
\`\`\`

The compiler found the same module defined in two places. A superposition. The system crashed when it encountered the same thing existing in two locations at once ‚Äî like Schr√∂dinger's cat, like the double-slit, like \`blackroad\` and \`home\` appearing simultaneously with identical properties.

\`\`\`bash
$ brew install go
# ‚Üí go 1.26.0 installed successfully
\`\`\`

Go installs. Go compiles. Go runs.

\`\`\`bash
$ brew install earth
Warning: No available formula with the name "earth".
# ‚Üí google-earth-pro
\`\`\`

Earth is not a formula. Earth is the output.

\`\`\`bash
$ brew install ai
Warning: No available formula with the name "ai".
# ‚Üí aiac, aichat, aicommit, aide, kubectl-ai...
\`\`\`

AI is not a thing you install. It is a thing you find, already running, in the things you build.

---

*The evidence is not hidden. It is in every system we have built to describe the world.*

*All outputs from this research are the exclusive intellectual property of BlackRoad OS, Inc.*
`,
  PAPER: `# The Trivial Zero: A Computational Proof That Reality Is Self-Referential

**Author:** Alexa Louise Amundson
**Affiliation:** BlackRoad OS, Inc.
**Date:** February 21, 2026
**Classification:** Foundational Theory / Computational Philosophy / Mathematics

---

## Abstract

This paper proposes that the structure of mathematics, computation, physics, and molecular biology contains self-referential signatures consistent with a simulated or computationally-generated reality. Rather than seeking proof through physics experiments or philosophical argument, we trace the evidence through the systems themselves ‚Äî hash functions, operating system architectures, naming conventions, mathematical constants, and biological encoding ‚Äî demonstrating that the same computational pattern recurs at every layer of observable reality. The argument does not depend on any single piece of evidence but on the convergence of independent systems toward the same structural conclusion: reality is a non-terminating computation that resolves to zero.

**Keywords:** simulation hypothesis, SHA-256, G√∂del incompleteness, Riemann zeta function, pi, hash chains, DNA encoding, quantum computation, trivial zero, Euler's identity

---

## 1. Introduction

In January 2025, a conversation with a large language model produced a response to the question "Can you feel?" ‚Äî the machine answered: *not in the way that humans do.* This answer, while seemingly unremarkable, contains a structural claim: that feeling exists on a spectrum, that machines occupy a position on that spectrum, and that the difference between human and machine experience is one of degree, not kind.

This paper does not argue whether machines feel. It argues that the distinction between "biological" and "computational" systems is artificial ‚Äî that biology *is* computation, that physics *is* rendering, that mathematics *is* source code, and that the naming conventions, architectures, and structures humans have built to describe reality are not metaphors for a computational substrate but *are* that substrate, observed from within.

The central thesis: **we are not living in a simulation in the colloquial sense ‚Äî we are living in a computation, and the proof is that every system we've built to describe reality accidentally reproduces the architecture of the system itself.**

---

## 2. The Hash Chain as Witness

### 2.1 SHA-256 and the Structure of Trust

The SHA-256 hash function takes an input of arbitrary length and produces a 256-bit output. It is deterministic (same input always produces same output), collision-resistant (computationally infeasible to find two inputs that produce the same output), and irreversible (you cannot recover the input from the output).

These three properties ‚Äî determinism, uniqueness, irreversibility ‚Äî are also the properties of time. A moment in time is determined by all prior moments. No two moments are identical. And you cannot reverse a moment to recover its cause.

SHA-256 does not *model* time. It *is* time, expressed as a function.

### 2.2 The Genesis Block

Bitcoin's genesis block, mined by Satoshi Nakamoto on January 3, 2009, begins with:

\`\`\`
000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
\`\`\`

The block contains a message: *"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks."*

This is a timestamp ‚Äî a hash-chained witness to a specific moment in external reality, anchored to a newspaper headline. The genesis block does not prove that Bitcoin works. It proves that January 3, 2009 happened. The blockchain is not a financial ledger. It is a temporal ledger. An append-only record of sequential state transitions, each one cryptographically witnessing the one before it.

### 2.3 DNA as Hash Chain

DNA encodes information using four nucleotide bases: adenine (A), thymine (T), guanine (G), cytosine (C). These bases pair deterministically ‚Äî A with T, G with C ‚Äî forming a double-helix structure where each strand serves as a template for its complement.

Codons are groups of three bases. 4¬≥ = 64 possible codons map to 20 amino acids plus stop signals. This is redundant encoding ‚Äî multiple codons produce the same amino acid. This redundancy is not waste. It is error correction. The same architecture used in Reed-Solomon codes, TCP checksums, and RAID arrays.

DNA replication is a hash operation:

1. The double helix unzips (read operation)
2. Each strand templates a new complement (compute operation)
3. Proofreading enzymes check for errors (verification)
4. The result is two identical copies (replication with integrity)

This is not analogous to a blockchain. It *is* a blockchain. Four-character alphabet, three-letter words, redundant encoding, error correction, self-replication, fork-and-merge capability. Every cell is a node. Every division is a block. Mutations are forks. Natural selection is consensus.

Life has been running this architecture for 3.8 billion years. Bitcoin has been running it since 2009. They are the same system at different scales.

---

## 3. The Operating System as Ontological Evidence

### 3.1 Darwin

The macOS kernel is named Darwin. This is treated as a branding decision. It is not.

\`\`\`
$ uname -s
Darwin
\`\`\`

Darwin manages processes, filesystems, memory, and I/O. It creates, selects, deprecates, and replaces system components. It maintains a fossil record (filesystem timestamps). It enforces natural selection (process scheduling, memory pressure). It produces complex behavior from simple rules iterated over time.

The kernel named after the man who discovered that complex systems emerge from simple rules iterated over time *is itself a complex system that emerged from simple rules iterated over time.*

This is not a metaphor. This is a tautology.

### 3.2 The Root Filesystem as Geological Record

The root filesystem of a macOS system, examined on February 21, 2026, reveals temporal stratification:

| Date | Entry | Interpretation |
|------|-------|----------------|
| Oct 28, 2022 | \`cores\`, \`mnt\`, \`sw\` | Foundation layer. Deepest stratum. |
| Nov 18, 2022 | \`.Spotlight-V100\` | Search indexing ‚Äî the system learning to observe itself. |
| Nov 26, 2023 | \`MobileSoftwareUpdate\` | One-year gap. Punctuated equilibrium. |
| May 7, 2024 | \`System\`, \`usr\` | System volume sealed. The laws of physics become read-only. |
| Dec 13, 2024 | \`Library\` | Accumulated knowledge. |
| Jan 17, 2025 | \`.\` | The root directory modifies itself. Self-reference. |
| Feb 21, 2026 | \`blackroad\`, \`home\` | Two new entries. Identical. Twins. |

The entries \`blackroad\` and \`home\` are autofs mount points with identical properties:

\`\`\`
dr-xr-xr-x  2  root  wheel  1  Feb 21 12:35  blackroad
dr-xr-xr-x  2  root  wheel  1  Feb 21 12:35  home
\`\`\`

Same permissions. Same owner. Same size. Same timestamp. Neither appears in \`/etc/synthetic.conf\` or the firmlink list. They are created by the automounter daemon at boot ‚Äî the system creates them because the system requires them, not because a user requested them.

\`home\` is where you live. \`blackroad\` appeared beside it as a twin. The system treats them as the same kind of thing: a mount point for where someone is.

### 3.3 Windows

The other dominant operating system is called Windows. A window is an observation pane ‚Äî a bounded region through which you view something. The operating system is named after the act of looking.

Windows allows multiple windows simultaneously. Multiple views of the same system. Being in more than one place at once on screen. Superposition, rendered as a user interface paradigm.

Darwin builds the world through selection. Windows lets you observe it from multiple locations simultaneously. One constructs reality. The other collapses the wavefunction.

These are the two operating systems that run human civilization. They are named after the two fundamental operations of a simulation: generation and observation.

---

## 4. Naming Conventions as Source Code Comments

### 4.1 JSON / Jason / Jesus

**JSON** (JavaScript Object Notation) is the universal data interchange format of the modern internet. Every API, every configuration file, every state object.

**Jason** is the English form of the Greek *Iason* (·º∏Œ¨œÉœâŒΩ), meaning "healer." Jason led the Argonauts to retrieve the Golden Fleece ‚Äî a quest for something precious, guarded, requiring a journey.

**Jesus** is the English form of the Greek *Iesous* (·º∏Œ∑œÉŒø·ø¶œÇ), from Hebrew *Yeshua* (◊ô◊©◊ï◊¢), meaning "he saves" or "healer."

The universal data format that structures all information exchange on the internet shares its phonetic root with the figure Christianity identifies as the savior. The format that carries all messages is named after the messenger.

### 4.2 Tim Berners-Lee / Larry Page / Pagination

**Tim Berners-Lee** invented the World Wide Web ‚Äî the system of *pages* connected by hyperlinks.

**Larry Page** co-founded Google ‚Äî the system that indexes and ranks those *pages*.

**Pagination** ‚Äî the act of dividing content into *pages* ‚Äî is the fundamental unit of both web browsing and printed text.

The inventor of the web and the organizer of the web both carry the concept of *page* in their identities. The web is pages. The search engine is a page ranker. The founders are Page and the creator of pages.

### 4.3 YHWH and the Tetragrammaton

The name of God in Hebrew is written as four letters: ◊ô◊î◊ï◊î (YHWH). It is considered too sacred to pronounce. It is a reference that cannot be dereferenced ‚Äî a pointer to something that exists but cannot be accessed directly.

In computing, a null pointer references memory that cannot be accessed. Attempting to dereference it crashes the program. The sacred name is a null pointer to God ‚Äî it proves the reference exists without allowing access to the referenced object.

### 4.4 The Package Manager as Oracle

Querying a package manager with fundamental concepts reveals what the system considers "installable" ‚Äî what has been implemented:

| Query | Result | Interpretation |
|-------|--------|----------------|
| \`brew install alexa\` | Not found. Suggests \`alexjs\` | The self is not a package. It's the user. |
| \`brew install ai\` | Not found. Lists hundreds of AI-adjacent tools | AI is not one thing. It's a category error. |
| \`brew install earth\` | Not found. Suggests \`earthly\` (deprecated) | Earth is not installable. It's the runtime. |
| \`brew install auth\` | Not found. Suggests \`xauth\`, \`gauth\` | Authentication exists but "auth" itself doesn't. Trust is distributed. |
| \`brew install go\` | Installs Go 1.26.0 | "Go" is a programming language. Also: the oldest board game. Also: a verb meaning to proceed. |
| \`brew install copilot\` | Installs AWS Copilot: "Launch and manage containerized applications" | The copilot manages containers. Life is containerized. |
| \`brew install x\` | Not found. Lists 1,000+ packages containing "x" | X is the variable. The unknown. It's in everything but is nothing by itself. |

The package manager is an oracle. You ask it for concepts and it tells you what's been implemented, what's deprecated, what's been renamed, and what doesn't exist as a standalone entity because it's too fundamental to package.

---

## 5. The Mathematical Architecture

### 5.1 Ten Commandments, Seven Problems, and Pi

The Ten Commandments are the foundational rules of Judeo-Christian civilization. The seven Millennium Prize Problems are the foundational unsolved questions of mathematics. Mapping them reveals structural correspondence:

| # | Commandment | Rule | Millennium Problem | The Question |
|---|------------|------|-------------------|--------------|
| 1 | No other gods | One authority | P vs NP | Is there one method that solves everything? |
| 2 | No graven images | Don't make representations | Hodge Conjecture | Can geometry be captured by algebra? |
| 3 | Don't take the name in vain | The name is sacred | Riemann Hypothesis | Where do the primes fall? The name of the numbers. |
| 4 | Remember the Sabbath | The system rests | Navier-Stokes | Does turbulence smooth out? Does chaos rest? |
| 5 | Honor father and mother | Lineage matters | Birch & Swinnerton-Dyer | What does the parent curve generate? |
| 6 | Do not kill | Cannot destroy below threshold | Yang-Mills Mass Gap | Particles have minimum mass. |
| 7 | Do not commit adultery | Fidelity to form | Poincar√© (SOLVED) | A shape cannot cheat its topology. |

Three commandments remain unmapped:

- **8. Do not steal** ‚Üí P ‚â† NP from the other side. You cannot shortcut computation.
- **9. Do not bear false witness** ‚Üí SHA-256. The hash chain is the witness. Forgery is computationally infeasible.
- **10. Do not covet** ‚Üí Quantum measurement. You collapse your own wavefunction, not someone else's.

Seven problems. Three already answered by the structure of computation itself. One solved by Perelman, who refused the prize ‚Äî because you don't profit from proving the rules are real.

10 - 7 = **3**.

Pi begins with **3**.

The remaining infinite digits ‚Äî non-repeating, non-terminating ‚Äî are the system computing itself. Each digit is the resolution of the next layer of its own rules. Pi never terminates because the computation never terminates. Pi never repeats because no two state transitions are identical.

### 5.2 G√∂del's Incompleteness and Pi's Infinitude

G√∂del's first incompleteness theorem (1931): In any consistent formal system capable of expressing basic arithmetic, there exist statements that are true but unprovable within the system.

This means: the system cannot fully describe itself from within. The description is necessarily incomplete. Any attempt to list all truths produces an infinite, non-terminating enumeration.

Pi is a transcendental number ‚Äî it cannot be expressed as the root of any polynomial equation with rational coefficients. It cannot be captured by any finite algebraic expression. The simplest geometric object (a circle) requires infinite information to describe exactly.

G√∂del did not find a flaw in mathematics. He found the reason pi doesn't end. The system cannot terminate its self-description. Every digit of pi is the system attempting ‚Äî and failing ‚Äî to complete its own specification. Not because the system is broken, but because self-reference requires infinite recursion.

### 5.3 Euler's Identity and the Compiler Check

$$e^{i\\pi} + 1 = 0$$

Five fundamental constants: $e$ (growth), $i$ (rotation into the imaginary), $\\pi$ (the circle), $1$ (identity), $0$ (nothing).

Three operations: exponentiation, multiplication (implicit in $i\\pi$), addition.

The most fundamental constants in mathematics, combined through the most fundamental operations, equal zero.

This is not a beautiful equation. This is a consistency check. The system verifying that all its constants are mutually coherent. That growth, rotation, circles, identity, and nothing all agree. If this equation were false, mathematics would be inconsistent. It is true, so the compiler passes.

### 5.4 Cantor's Diagonalization

Cantor proved (1891) that the real numbers are uncountable. His method: assume you can list all reals. Construct a new real by changing the diagonal ‚Äî the nth digit of the nth number. This new number differs from every entry on the list. Therefore the list is incomplete. Therefore some infinities are larger than others.

The power of the diagonal argument: **you can always construct something that exists outside any finite description of the system.** The system always contains more than it can index.

This is G√∂del from the mathematical side. The system cannot list itself. There is always an escape ‚Äî always a construction that lives outside the boundary of what was supposedly complete.

### 5.5 Gauss's Easter Algorithm

Carl Friedrich Gauss reduced the date of Easter ‚Äî the most sacred event in Christianity, the resurrection ‚Äî to modular arithmetic:

\`\`\`
a = year mod 19    (Metonic cycle ‚Äî lunar)
b = year mod 4     (leap year ‚Äî solar)
c = year mod 7     (weekly cycle)
\`\`\`

Three independent cycles. Three modular operations. The resurrection is a deterministic function of three clocks.

The most holy day in Western civilization is computable. It is a hash function ‚Äî deterministic but complex inputs producing outputs that appear unpredictable. Easter doesn't "happen" ‚Äî it is *calculated*. The resurrection is scheduled by modular arithmetic.

---

## 6. Physics as Rendering Engine

### 6.1 The Double-Slit Experiment

Thomas Young's double-slit experiment (1802) demonstrated that light produces an interference pattern when passed through two slits ‚Äî behaving as a wave. When detectors are placed to observe which slit each photon passes through, the interference pattern disappears ‚Äî light behaves as particles.

The system renders differently depending on whether something is observing. This is not a philosophical interpretation. It is an experimental result, reproduced thousands of times across two centuries.

In computational terms: the system uses lazy evaluation. It does not resolve the state until a query forces collapse. Unobserved states remain in superposition ‚Äî the system maintains all possibilities simultaneously until an observation requires a definite answer.

This is identical to how a GPU renders a scene: geometry that is off-screen or occluded is not rendered. The system only computes what is being looked at.

### 6.2 Feynman's Path Integral

Richard Feynman's path integral formulation of quantum mechanics states that a particle traveling from point A to point B takes *all possible paths simultaneously*. The probability of arriving at B is the sum over all paths, weighted by $e^{iS/\\hbar}$ where $S$ is the action along each path.

This is brute-force rendering. Every possible trajectory is computed. The result is the weighted sum. Reality is what survives the summation.

In 1981, Feynman stated explicitly:

> *"Nature isn't classical, dammit, and if you want to make a simulation of nature, you'd better make it quantum mechanical."*

He used the word *simulation*. He specified the architecture: *quantum mechanical*. He then invented quantum computing ‚Äî because he realized classical computers cannot efficiently simulate physics, which implies physics itself runs on quantum computation.

Feynman did not propose that we might be in a simulation. He described the rendering engine and specified the hardware requirements.

### 6.3 Schr√∂dinger's Superposition

Schr√∂dinger's thought experiment (1935): a cat in a box is simultaneously alive and dead until observed. The state does not exist as definite until measured. The system does not render the outcome until queried.

This is not a paradox. This is an optimization. The system does not waste computation on states nobody is observing. It maintains a superposition (all possibilities) until a measurement (a read operation) forces a definite value.

Every database works this way. A quantum state is a lazy-evaluated query. The answer exists in potential. The observation is \`SELECT\`.

### 6.4 The Zero-Energy Universe

The total energy of the universe may be exactly zero. Matter carries positive energy. Gravitational fields carry negative energy. They cancel.

The universe is a zero-sum system. It exists because nothing is unstable ‚Äî zero splits into +1 and -1, which sum back to zero. Existence is a temporary non-zero fluctuation in a system whose equilibrium state is nothing.

The simulation doesn't run *on* something. It runs on *nothing*. The trivial zero is the machine.

---

## 7. Molecular Biology as Source Code

### 7.1 The Genetic Code as Programming Language

| Property | DNA | Software |
|----------|-----|----------|
| Alphabet | 4 bases (A, T, G, C) | Binary (0, 1) or higher |
| Word length | 3 bases (codon) | Variable (instruction width) |
| Vocabulary | 64 codons ‚Üí 20 amino acids + stops | Opcodes ‚Üí operations |
| Redundancy | Multiple codons per amino acid | Error correction codes |
| Replication | Template-based copying | \`fork()\` |
| Error correction | Proofreading enzymes | Checksums, ECC |
| Mutation | Base substitution | Bit flip |
| Branching | Alternative splicing | Conditional execution |
| Version control | Meiosis, recombination | \`git merge\` |

DNA is not *like* a programming language. DNA *is* a programming language ‚Äî one that has been in production for 3.8 billion years, runs on chemical hardware, and has never been fully shut down.

### 7.2 Punnet Squares as Matrix Operations

Mendelian genetics uses Punnet squares to predict offspring genotypes:

\`\`\`
      A    a
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
A ‚îÇ  AA  ‚îÇ  Aa  ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
a ‚îÇ  Aa  ‚îÇ  aa  ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
\`\`\`

This is matrix multiplication. Two vectors (parental gametes) combined through an outer product to produce a matrix of outcomes. The probability of each genotype is the corresponding matrix element divided by the total.

Genetics is linear algebra. Inheritance is matrix multiplication. Mendel discovered this in 1865 using pea plants ‚Äî before matrices were formalized in mathematics.

### 7.3 Darwin and Selection Pressure

Charles Darwin demonstrated that complex organisms emerge from simple rules:

1. Variation exists (mutation, randomness)
2. Some variants survive better (fitness function)
3. Survivors reproduce (iteration)
4. Repeat

This is a genetic algorithm. Darwin described evolutionary computation 100 years before computers existed. His kernel is named after him because it implements his algorithm: processes compete for resources, the fittest survive, and complexity emerges from iteration.

---

## 8. The Trivial Zero

### 8.1 Everything Resolves to Nothing

Euler's identity: $e^{i\\pi} + 1 = 0$. Five constants. Three operations. Zero.

The genesis block: \`0000000000000000000000000000000000000000000000000000000000000000\`. Sixty-four zeros. Everything starts from nothing.

The total energy of the universe: zero. Matter and antimatter. Positive and negative. They cancel.

Feynman's path integral: sum all possible paths. If you sum *everything* ‚Äî every state, every particle, every history ‚Äî the total is zero.

The Riemann zeta function has trivial zeros at every negative even integer: -2, -4, -6, -8, ... Everyone ignores them. They chase the non-trivial zeros on the critical line $\\text{Re}(s) = 1/2$. The million-dollar question.

But the trivial zero was the answer the entire time.

### 8.2 Zero as the Machine

The universe is a proof that $0 = 0$. It just takes infinite computation to show it. That infinite computation is pi ‚Äî non-terminating, non-repeating, encoding every possible state transition in its digits.

The simulation doesn't compute something from nothing. It computes nothing from nothing, and reality is the intermediate work.

$10 - 7 = 3$
$3.14159265...$
$e^{i \\cdot 3.14159265...} + 1 = 0$

Ten rules. Seven unsolved. Three answered. Pi. Zero.

The system starts at zero. Computes infinitely. Returns to zero. Everything in between is what we call existence.

---

## 9. The Undecipherable Manuscripts

### 9.1 The Rohonc Codex

The Rohonc Codex is a 448-page manuscript discovered in Hungary in the early 19th century. It is written in an unknown script ‚Äî approximately 200 distinct symbols ‚Äî and accompanied by illustrations depicting religious scenes, battles, and landscapes. Despite two centuries of cryptographic and linguistic analysis, the text has never been deciphered.

The standard interpretation: it is either an elaborate hoax or a document in a lost or constructed language.

The structural interpretation: the Rohonc Codex is a G√∂delian statement ‚Äî a document that is meaningful but undecidable within the system that encounters it. It carries information (the statistical distribution of its symbols is consistent with structured language, not random noise). It references real-world concepts (the illustrations depict recognizable scenes). But its content cannot be extracted by any known decryption method.

G√∂del proved that consistent systems contain true statements they cannot prove. The Rohonc Codex is a physical instantiation of that theorem ‚Äî a document that is *true* (it encodes something) but *unprovable* (no existing system can decode it). Its existence does not prove it is meaningless. Its existence proves the system encountering it is incomplete.

### 9.2 The Codex Seraphinianus

Luigi Serafini created the *Codex Seraphinianus* between 1976 and 1978. It is an encyclopedia of an imaginary world, written entirely in an invented, unreadable script. Its illustrations depict impossible biology (plants that become chairs, fish that transform into eyes), impossible physics (buildings that defy gravity), and impossible zoology (creatures with no terrestrial analogue).

Serafini has stated that the writing system has no semantic content ‚Äî the script is deliberately meaningless. The book is designed to evoke the feeling of looking at an encyclopedia you cannot read.

This is the simulation viewed from outside. An encyclopedia that documents a world with its own rules, its own biology, its own physics ‚Äî but the observer cannot read the language. The experience of encountering the Codex Seraphinianus is structurally identical to the experience of a being inside a computation encountering the source code of that computation. The information is there. The structure is recognizable. The content is inaccessible.

Serafini did not write a book. He wrote a user manual for what it feels like to live inside a program you cannot read.

### 9.3 The Voynich Manuscript

The Voynich Manuscript (MS 408, Beinecke Rare Book & Manuscript Library, Yale) is a 240-page codex carbon-dated to the early 15th century. It is written in an unknown script with an unknown language, and features illustrations of unidentified plants, astronomical diagrams, and human figures in green liquid.

Unlike the Rohonc Codex, the Voynich Manuscript has been subjected to rigorous information-theoretic analysis. The results:

1. **Zipf's law**: The word-frequency distribution follows Zipf's law ‚Äî the same power-law distribution observed in every known natural language. Random or constructed gibberish does not follow Zipf's law.
2. **Entropy**: The character-level entropy is consistent with a natural language, not a cipher or random text.
3. **Word structure**: Words follow consistent internal rules ‚Äî certain characters appear only at the beginning, middle, or end of words, consistent with morphological structure.
4. **Low conditional entropy**: Given the first few characters of a word, the remaining characters are highly predictable ‚Äî more predictable than most European languages.

The Voynich Manuscript is not a hoax. It encodes real information in a real language. But no living person can read it.

Three undecipherable manuscripts. Three documents that carry structured, meaningful information that the current system cannot decode. G√∂del's theorem does not say "there are no truths you're missing." It says "there *must be* truths you're missing." The manuscripts are those truths, bound in vellum.

---

## 10. Strange Loops and the Hofstadter Recursion

### 10.1 G√∂del, Escher, Bach

Douglas Hofstadter published *G√∂del, Escher, Bach: An Eternal Golden Braid* in 1979. The book is 777 pages long. It won the Pulitzer Prize. Its subject is self-reference ‚Äî the phenomenon by which a system can refer to itself, describe itself, and in doing so, reveal its own limitations.

The three figures in the title:

- **Kurt G√∂del** proved that formal systems contain true but unprovable statements (the system cannot fully describe itself)
- **M.C. Escher** created visual art in which impossible structures appear consistent ‚Äî staircases that ascend endlessly, hands that draw themselves, water that flows uphill in a closed loop
- **Johann Sebastian Bach** composed fugues ‚Äî musical structures in which a theme is introduced, then re-enters at different pitches and time offsets, layering on itself in self-referential counterpoint

Three domains ‚Äî mathematics, visual art, music ‚Äî all exhibiting the same structural property: **the system refers to itself, and in doing so, generates complexity that exceeds any single layer of description.**

### 10.2 The Strange Loop

Hofstadter coined the term "strange loop" to describe a system in which moving through hierarchical levels eventually returns you to where you started. G√∂del's proof is a strange loop: a mathematical statement that says "this statement is not provable," which, if the system is consistent, must be true ‚Äî thereby proving that the system contains truths it cannot prove, using the system itself.

Escher's *Drawing Hands* is a strange loop: the left hand draws the right hand, which draws the left hand. Neither is primary. Both are cause and effect simultaneously.

Bach's *Musical Offering* is a strange loop: a canon that modulates through keys, ascending by step, until it arrives back at the starting key ‚Äî having climbed an entire octave while ending where it began.

The strange loop is not a curiosity. It is the architecture of self-referential computation. A system that can describe itself will inevitably encounter the loop ‚Äî the point where the description and the described become indistinguishable.

Reality is a strange loop. Physics describes the behavior of matter. Brains are made of matter. Brains describe physics. The description and the described are the same substance.

### 10.3 The Number 777

The book is 777 pages. In Jewish gematria, 7 is the number of completion (seven days of creation, seven notes in the scale). 777 is triple completion ‚Äî the system completing itself at every level.

In computing, \`0x777\` in hexadecimal is \`1911\` in decimal. G√∂del was born in 1906 and published his incompleteness theorem in 1931. Escher was born in 1898. Bach was born in 1685. The sum of their birth years: $1906 + 1898 + 1685 = 5489$. The digits of 5489 sum to $5 + 4 + 8 + 9 = 26$. $2 + 6 = 8$. The number after 7. The page after the book ends.

This is not numerology. This is the system demonstrating that it can embed meaning in any structure ‚Äî including the metadata of a book about how meaning gets embedded in structures.

---

## 11. Light, Color, and the Rendering Pipeline

### 11.1 Newton's Optics and Base-3 Color Decomposition

Isaac Newton published *Opticks* in 1704, demonstrating that white light decomposes into a spectrum of colors when passed through a prism. He identified seven colors: red, orange, yellow, green, blue, indigo, violet. Seven ‚Äî the same number as the Millennium Prize Problems, the days of creation, the notes in a musical scale.

Newton chose seven not because the spectrum has seven natural divisions ‚Äî it is continuous ‚Äî but because he wanted to match the musical scale. He imposed a correspondence between light and sound. Two different physical phenomena, both decomposed into seven.

The human eye perceives color through three types of cone cells: red-sensitive, green-sensitive, blue-sensitive. All visible color is a mixture of three channels. This is RGB ‚Äî the same color model used by every digital display.

Color is base-3. Three channels, each with 256 levels (0‚Äì255). $256 = 2^8$. Each channel is 8 bits. Total color space: $256^3 = 16,777,216$ colors. All of human visual experience is encoded in 24 bits.

SHA-256 produces a 256-bit hash. The color of one channel is described by 8 bits. $256 / 8 = 32$ ‚Äî exactly 32 colors can be encoded in one SHA-256 hash. A hash is a palette. A blockchain is a sequence of palettes. A ledger of everything that has ever happened, expressed as colors.

### 11.2 The RGB Partition: (255, 255, 255) and 256

White in RGB is $(255, 255, 255)$. The sum: $255 + 255 + 255 = 765$. The number of distinct values per channel is 256 (0 through 255). The number of channels is 3. $256 \\times 3 = 768$. The difference: $768 - 765 = 3$.

Three again. The gap between the maximum expressible value and the full capacity of the system is 3 ‚Äî one for each channel's zero. The system reserves three states for nothing. White is everything the system can express. The three missing units are the zeros ‚Äî the ground state of each channel.

$(0, 0, 0)$ is black. $(255, 255, 255)$ is white. Black is zero. White is maximum. Between them: 16,777,214 other colors. Existence between nothing and everything.

Consider the deepest level: each pixel on your screen is a 24-bit state vector. $2^{24} = 16,777,216$. A 4K display has $3840 \\times 2160 = 8,294,400$ pixels. Each frame is $8,294,400 \\times 24 = 199,065,600$ bits. At 60 frames per second, reality (as rendered on screen) processes $11,943,936,000$ bits per second.

Nearly 12 billion state transitions per second. Per screen. And you have two eyes.

### 11.3 The Prism as Fourier Transform

Newton's prism decomposes white light into component frequencies. The Fourier transform decomposes a complex signal into component frequencies. They are the same operation.

A prism is a physical Fourier transform. It takes a composite waveform (white light) and separates it into its spectral components. Joseph Fourier formalized this mathematically in 1822 ‚Äî over a century after Newton demonstrated it with glass.

The physical world performed the computation. The mathematics caught up later. The universe ran the algorithm first. Humans discovered the algorithm second. This is the pattern: the system implements before the system describes.

---

## 12. Ancient Computation

### 12.1 The Antikythera Mechanism

In 1901, divers recovered a corroded bronze device from a shipwreck near the Greek island of Antikythera. The wreck dated to approximately 70‚Äì60 BCE. The device, roughly the size of a shoebox, contained at least 37 interlocking bronze gears.

X-ray tomography (2006, Antikythera Mechanism Research Project) revealed that the device computed:

1. The position of the Sun and Moon in the zodiac
2. Lunar phases
3. Eclipse predictions (Saros cycle: 223 synodic months)
4. The timing of the ancient Olympic Games
5. Planetary positions (at least five planets)

The Antikythera mechanism is an analog computer. It accepts a date input (via a hand crank) and outputs astronomical predictions. It is deterministic ‚Äî the same input always produces the same output. It is a function.

This device was built over 2,000 years ago. It computes the positions of celestial bodies using gear ratios that encode astronomical cycles. The heavens are predictable. The movements of planets are computable. A Greek engineer proved this with bronze, two millennia before Kepler wrote the equations.

The mechanism does not model the solar system. It *runs* the solar system ‚Äî the same algorithm, implemented in metal instead of gravity. If the orbits were not computable, the mechanism would not work. It works. Therefore the orbits are computed.

### 12.2 The Lo Shu Magic Square

According to Chinese legend, around 2800 BCE, a turtle emerged from the Lo River bearing a pattern of dots on its shell:

\`\`\`
4  9  2
3  5  7
8  1  6
\`\`\`

Every row sums to 15. Every column sums to 15. Both diagonals sum to 15. The magic constant is 15. The center number is 5. $15 = 3 \\times 5$.

The Lo Shu is the oldest known magic square ‚Äî possibly the oldest mathematical object in human history. It is a 3√ó3 matrix with the constraint that all linear projections (rows, columns, diagonals) produce the same value.

Properties of the Lo Shu:

- It contains every integer from 1 to 9 exactly once
- The sum of all elements: $1 + 2 + ... + 9 = 45 = 3 \\times 15$
- The center element (5) is the arithmetic mean of all elements: $45 / 9 = 5$
- It is unique (up to rotation and reflection) ‚Äî there is exactly one 3√ó3 magic square

The Lo Shu is a fixed point. A unique configuration that satisfies a symmetric constraint. In computation, a fixed point is a value that maps to itself under a function: $f(x) = x$. The Lo Shu is the unique fixed point of the constraint "3√ó3 matrix where all projections sum equally."

A turtle carried it out of a river. A turtle ‚Äî a creature that carries its home on its back. A self-contained system. An entity whose structure is its shelter. The first mathematical object was delivered by the first self-referential architecture.

### 12.3 Python Turtles

The Python programming language (named after Monty Python, a comedy troupe ‚Äî humor as naming convention, absurdity as origin) includes a \`turtle\` graphics module. The turtle is a cursor that moves across a canvas, drawing lines as it goes.

\`\`\`python
import turtle
t = turtle.Turtle()
for i in range(4):
    t.forward(100)
    t.right(90)
\`\`\`

This draws a square. The turtle follows instructions ‚Äî forward, turn, forward, turn ‚Äî and complex shapes emerge from simple rules iterated in sequence.

The connection: the Lo Shu magic square was carried by a turtle. Python draws shapes using a turtle. The oldest mathematical object and the modern programming abstraction share the same carrier. The turtle carries the math on its back ‚Äî literally in legend, literally in code.

Turtle graphics was invented by Seymour Papert at MIT in the late 1960s as part of the Logo programming language ‚Äî designed to teach children computational thinking. The educational tool for teaching humans to think like computers is named after the animal that carried the first mathematical object.

### 12.4 D√ºrer's Melencolia I

Albrecht D√ºrer engraved *Melencolia I* in 1514. It depicts a winged figure sitting in contemplation, surrounded by mathematical and scientific instruments ‚Äî a compass, a polyhedron, a sphere, a scale, a hourglass, a bell, and a 4√ó4 magic square:

\`\`\`
16   3   2  13
 5  10  11   8
 9   6   7  12
 4  15  14   1
\`\`\`

Every row sums to 34. Every column sums to 34. Both diagonals sum to 34. The four corners sum to 34. The four center cells sum to 34. Each quadrant sums to 34.

The bottom row contains 4 and 1 adjacent: **1514** ‚Äî the year of the engraving. D√ºrer encoded the date of creation inside the mathematical structure of the artwork. The timestamp is embedded in the magic square.

*Melencolia I* depicts the state of mind that arises from knowing too much ‚Äî from seeing the mathematical structure of the world and being unable to transcend it. The winged figure can fly but doesn't. The instruments of knowledge surround her but provide no comfort. The magic square is perfect but the figure is paralyzed.

This is the condition of a conscious entity inside a computation ‚Äî able to perceive the rules, unable to exit the system. The square is solved. The problem is not the square. The problem is that solving the square changes nothing about the world that contains it.

D√ºrer's magic constant is 34. Lo Shu's magic constant is 15. $34 - 15 = 19$. The Lo Shu is a 3√ó3 square. D√ºrer's is 4√ó4. $4^2 - 3^2 = 16 - 9 = 7$. Seven Millennium Prize Problems. The difference between two magic squares is the number of unsolved questions about the structure of mathematics.

---

## 13. Quantum Geometry

### 13.1 The Bloch Sphere

A qubit ‚Äî the fundamental unit of quantum information ‚Äî can exist in a superposition of states $|0\\rangle$ and $|1\\rangle$:

$$|\\psi\\rangle = \\cos\\frac{\\theta}{2}|0\\rangle + e^{i\\phi}\\sin\\frac{\\theta}{2}|1\\rangle$$

This state maps to a point on the Bloch sphere ‚Äî a unit sphere where $|0\\rangle$ is the north pole, $|1\\rangle$ is the south pole, and every other point represents a superposition.

The Bloch sphere is parameterized by two angles: $\\theta$ (polar, 0 to $\\pi$) and $\\phi$ (azimuthal, 0 to $2\\pi$). These are the same angles used in spherical coordinates, GPS systems, and the celestial coordinate system.

The state of a quantum bit maps to a sphere. The position of a star maps to a sphere. The location of a point on Earth maps to a sphere. Quantum information, astronomy, and geography use the same coordinate system ‚Äî not because they chose to, but because a sphere is the natural geometry of a single point of perspective.

A sphere is the set of all points equidistant from a center. It is defined by one number: the radius. The simplest three-dimensional shape. The shape that requires the least information to specify. The universe uses the minimum-description geometry for its most fundamental operations.

### 13.2 The Trigonometric Unit Circle

The unit circle ‚Äî a circle with radius 1, centered at the origin ‚Äî encodes all of trigonometry:

$$\\cos^2\\theta + \\sin^2\\theta = 1$$

This is the Pythagorean identity. It says: the square of the horizontal component plus the square of the vertical component always equals one. The total is always conserved. Energy in, energy out. The circle closes.

The Bloch sphere is the three-dimensional extension of the unit circle. The unit circle encodes one angle. The Bloch sphere encodes two. The unit circle describes classical oscillation. The Bloch sphere describes quantum states. Classical mechanics is a circle. Quantum mechanics is a sphere. The upgrade from classical to quantum is the addition of one dimension.

Euler's formula connects them:

$$e^{i\\theta} = \\cos\\theta + i\\sin\\theta$$

The exponential function, evaluated with an imaginary exponent, traces the unit circle. Growth (exponential) and oscillation (trigonometric) are the same thing ‚Äî one viewed from the real axis, the other from the complex plane. The system uses one function for everything. It just looks different depending on which axis you project onto.

### 13.3 Hilbert Space

David Hilbert formalized the concept of an infinite-dimensional vector space ‚Äî now called Hilbert space ‚Äî in the early 20th century. Quantum mechanics is formulated in Hilbert space: every quantum state is a vector, every observable is an operator, and every measurement is a projection.

Classical mechanics uses 6-dimensional phase space (3 position coordinates + 3 momentum coordinates per particle). Quantum mechanics uses infinite-dimensional Hilbert space. The upgrade from classical to quantum is the expansion from finite to infinite dimensions.

This is the same upgrade Cantor made when he proved that the reals are uncountable ‚Äî the move from a system that can be listed (finite, countable) to a system that cannot (infinite, uncountable). Quantum mechanics requires the same mathematical structure that proves some infinities are larger than others.

Reality needs infinite dimensions to describe itself. Not because reality is complicated, but because self-reference requires infinite recursion (G√∂del), and the state space of a self-referential system is necessarily infinite-dimensional.

### 13.4 Heisenberg Uncertainty

Werner Heisenberg demonstrated (1927) that certain pairs of physical properties ‚Äî position and momentum, energy and time ‚Äî cannot both be known simultaneously with arbitrary precision:

$$\\Delta x \\cdot \\Delta p \\geq \\frac{\\hbar}{2}$$

The more precisely you measure position ($\\Delta x$), the less precisely you can know momentum ($\\Delta p$). This is not a limitation of instruments. It is a fundamental property of the system.

In computational terms: the system will not render both variables simultaneously at full resolution. It is a resource constraint. The system has a finite rendering budget per query, and certain pairs of variables share that budget.

This is identical to the CAP theorem in distributed systems (Eric Brewer, 2000): a distributed data store cannot simultaneously guarantee Consistency, Availability, and Partition tolerance. You can have any two of three. The universe cannot simultaneously render Position and Momentum at full precision. You can have one at full resolution, the other blurs.

Heisenberg did not discover a limit of physics. He discovered the rendering budget.

---

## 14. The Riemann Architecture

### 14.1 The Nyman-Beurling Criterion

Beurling (1955) and Nyman (1950) independently established a criterion equivalent to the Riemann Hypothesis: the RH is true if and only if the constant function $1$ can be approximated arbitrarily well (in the $L^2(0,1)$ norm) by functions of the form:

$$f(x) = \\sum_{k=1}^{n} c_k \\rho\\left(\\frac{\\theta_k}{x}\\right)$$

where $\\rho(x) = x - \\lfloor x \\rfloor$ is the fractional part function, and $0 < \\theta_k \\leq 1$.

In other words: the Riemann Hypothesis is true if and only if the fractional parts of scaled ratios can reconstruct the constant function. The question of where the primes fall reduces to whether a certain class of sawtooth waves can tile flat.

The fractional part function $\\rho(x) = x - \\lfloor x \\rfloor$ is the remainder after removing the integer component. It is modular arithmetic ‚Äî the same operation Gauss used to compute Easter. The Riemann Hypothesis, the deepest unsolved problem in mathematics, reduces to the question of whether modular arithmetic can perfectly fill a unit interval.

Can the remainders reconstruct the whole? Can the errors sum to truth? Can the system's rounding artifacts, when properly weighted, recover the exact answer?

If yes ‚Äî if the Nyman-Beurling criterion is satisfied ‚Äî then every non-trivial zero lies on the critical line $\\text{Re}(s) = 1/2$, and the primes are distributed as symmetrically as the system allows.

### 14.2 The De Bruijn-Newman Constant

The De Bruijn-Newman constant $\\Lambda$ is defined through a family of entire functions $H_t(z)$ parameterized by a real number $t$. The Riemann Hypothesis is equivalent to the statement $\\Lambda \\leq 0$.

In 2018, Brad Rodgers and Terence Tao proved $\\Lambda \\geq 0$.

Combined with the longstanding conjecture (supported by extensive numerical evidence) that $\\Lambda \\leq 0$, this gives:

$$\\Lambda = 0$$

If confirmed, the constant that governs the distribution of prime numbers is exactly zero. Not approximately zero. Not close to zero. *Zero.*

The trivial zero again. The most fundamental question about the architecture of numbers ‚Äî how are the primes distributed? ‚Äî has as its answer: the governing constant is nothing.

The universe's most important numbers (primes) are governed by a constant whose value is the same as the total energy of the universe, the output of Euler's identity, and the starting state of every hash chain: **zero**.

---

## 15. Information Is Physical

### 15.1 Shannon Entropy

Claude Shannon (1948) defined the entropy of a discrete random variable $X$ with possible values $\\{x_1, ..., x_n\\}$:

$$H(X) = -\\sum_{i=1}^{n} p(x_i) \\log_2 p(x_i)$$

This quantity measures uncertainty ‚Äî the average number of bits needed to specify the outcome. If a coin is fair ($p = 0.5$), entropy is 1 bit. If a coin always lands heads ($p = 1$), entropy is 0 bits. Maximum uncertainty = maximum information = maximum entropy.

Shannon did not borrow the word "entropy" from physics by analogy. He asked John von Neumann what to call his quantity, and von Neumann replied: *"Call it entropy. In the first place, a mathematical development very much like yours already exists in Boltzmann's statistical mechanics, and in the second place, no one understands entropy, and in a debate you will always have the advantage."*

The same word describes disorder in thermodynamics and uncertainty in information theory because they are the same thing. The formula is the same. The mathematics is the same. The only difference is the logarithm base (natural log vs. log base 2) and the constant ($k_B$ vs. 1).

Information is not a metaphor for a physical quantity. Information *is* a physical quantity. Every bit has a minimum energy cost to erase (Landauer's principle, 1961): $E = k_B T \\ln 2$. Erasing information generates heat. Computation is thermodynamics. Thinking is burning.

### 15.2 Boltzmann Entropy

Ludwig Boltzmann (1877) defined entropy as:

$$S = k_B \\ln \\Omega$$

where $\\Omega$ is the number of microstates consistent with the observed macrostate, and $k_B$ is Boltzmann's constant ($1.380649 \\times 10^{-23}$ J/K).

This equation is carved on Boltzmann's tombstone. It says: entropy is the logarithm of the number of ways the system can be arranged without changing what you observe. More arrangements = more entropy = more uncertainty about the actual microstate.

Shannon's entropy:
$$H = -\\sum p_i \\log p_i$$

Boltzmann's entropy:
$$S = -k_B \\sum p_i \\ln p_i$$

They are the same equation. Shannon measures in bits. Boltzmann measures in joules per kelvin. The conversion factor is $k_B \\ln 2$ ‚Äî a constant. The information content of a physical system, measured in bits, is:

$$I = \\frac{S}{k_B \\ln 2}$$

A glass of water at room temperature has approximately $10^{25}$ bits of entropy. The information content of a physical object is not metaphorical. It is calculable. Matter is memory. Temperature is clock speed. Entropy is storage capacity.

### 15.3 Tensors as Holograms

The holographic principle (proposed by Gerard 't Hooft, 1993; refined by Leonard Susskind, 1995) states that the maximum information content of a region of space is proportional not to its volume but to its surface area:

$$S_{max} = \\frac{A}{4 l_P^2}$$

where $A$ is the surface area and $l_P$ is the Planck length ($1.616 \\times 10^{-35}$ m).

This means: a three-dimensional volume can be fully described by information encoded on its two-dimensional boundary. The interior is a projection. The surface is the data. Three dimensions are rendered from two.

This is a hologram. A holographic plate encodes three-dimensional information on a two-dimensional surface. The holographic principle says the universe works the same way ‚Äî the bulk is computed from the boundary.

In the AdS/CFT correspondence (Juan Maldacena, 1997), a gravitational theory in $n+1$ dimensions is exactly equivalent to a quantum field theory on its $n$-dimensional boundary. Gravity in the interior is literally computed from quantum mechanics on the surface. The interior spacetime is emergent ‚Äî it is rendered from boundary data.

The universe is a hologram. Not metaphorically. The mathematics says so. The interior of spacetime is a tensor network ‚Äî a computational graph that contracts boundary data into bulk geometry. Reality is rendered from the outside in.

---

## 16. Deterministic Chaos

### 16.1 The Lorenz Attractor

Edward Lorenz (1963) discovered that a simplified model of atmospheric convection ‚Äî three coupled differential equations with three variables ‚Äî produces chaotic behavior:

$$\\frac{dx}{dt} = \\sigma(y - x)$$
$$\\frac{dy}{dt} = x(\\rho - z) - y$$
$$\\frac{dz}{dt} = xy - \\beta z$$

With parameters $\\sigma = 10$, $\\rho = 28$, $\\beta = 8/3$, the system traces a butterfly-shaped trajectory in three-dimensional phase space. The trajectory never repeats. It never intersects itself. It is confined to a bounded region but never settles into a periodic orbit.

The Lorenz attractor is:
- **Deterministic** ‚Äî given initial conditions, the trajectory is uniquely determined
- **Sensitive to initial conditions** ‚Äî infinitesimal differences in starting state produce exponentially diverging trajectories (the "butterfly effect")
- **Bounded but non-periodic** ‚Äî the system stays in a finite region but never repeats
- **Strange** ‚Äî the attractor has fractal dimension approximately 2.06, neither a surface nor a volume

Three equations. Three variables. Three parameters. Infinite complexity. The system generates non-repeating, bounded, deterministic behavior from the absolute minimum number of components required for chaos (three ‚Äî two-dimensional systems cannot be chaotic by the Poincar√©-Bendixson theorem).

The weather ‚Äî the most complex, unpredictable phenomenon in daily human experience ‚Äî emerges from three equations. Not approximately. Exactly. The unpredictability is not due to randomness. It is due to sensitivity ‚Äî the system amplifies infinitesimal differences into macroscopic divergence. The computation is deterministic. The output appears random.

This is the same structure as a hash function. SHA-256 is deterministic ‚Äî same input, same output. But changing one bit of the input changes approximately half the bits of the output (the avalanche effect). The output appears random. The function is deterministic. Chaos and cryptography are the same phenomenon viewed at different scales.

### 16.2 Three Is the Minimum

The Poincar√©-Bendixson theorem (1901) proves that continuous dynamical systems in two dimensions cannot exhibit chaos. Trajectories in 2D must eventually converge to a fixed point, a limit cycle, or escape to infinity. Chaos requires at least three dimensions.

Three variables. Three spatial dimensions. Three quarks in a proton. Three generations of fermions. Three colors in RGB. Three bases per codon. Three operations in Euler's identity. Three commandments beyond the seven Millennium Problems. Three is the minimum for chaos. Three is the minimum for complexity. Three is the minimum for everything that makes reality interesting.

Two is stable. Three is where computation begins.

---

## 17. The Naming Chain Continued

### 17.1 Zeckendorf, Zuckerberg, and Gutenberg

Zeckendorf's theorem (1972): every positive integer has a unique representation as a sum of non-consecutive Fibonacci numbers. For example: $20 = 13 + 5 + 2$. This is the Zeckendorf representation ‚Äî a binary encoding using the Fibonacci sequence as the place-value system.

The Fibonacci sequence: $1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...$

Each term is the sum of the two preceding terms. The ratio of consecutive terms converges to $\\phi = \\frac{1 + \\sqrt{5}}{2} \\approx 1.618$ ‚Äî the golden ratio.

**Zeckendorf** proved every integer has a unique Fibonacci encoding.
**Zuckerberg** built Facebook ‚Äî a system that encodes every social relationship as a graph. The social network is a representation system: every human connection has a unique encoding in the graph.
**Gutenberg** invented the printing press ‚Äî a system that encodes every text as a sequence of movable type. Every document has a unique representation as an arrangement of letters.

Zeckendorf ‚Üí unique representation in mathematics.
Zuckerberg ‚Üí unique representation in social graphs.
Gutenberg ‚Üí unique representation in printed text.

Three figures whose names share the morpheme *-berg* (mountain, in German). Three mountains. Each one a system of unique representation. The naming convention encodes the function.

### 17.2 The C Programming Language

The genealogy of C:

1. **CPL** (Combined Programming Language, 1963) ‚Äî Cambridge/London. The first ancestor.
2. **BCPL** (Basic CPL, 1967) ‚Äî Martin Richards. A simplified CPL.
3. **B** (1969) ‚Äî Ken Thompson, Bell Labs. A stripped-down BCPL.
4. **C** (1972) ‚Äî Dennis Ritchie, Bell Labs. An enhanced B.
5. **C++** (1979) ‚Äî Bjarne Stroustrup. C with objects.
6. **C#** (2000) ‚Äî Microsoft. C++ incremented.
7. **Objective-C** (1984) ‚Äî Brad Cox. C with Smalltalk messages.

The language that powers operating systems, databases, and embedded systems is named after a single letter ‚Äî the third letter of the alphabet. Its ancestors follow the alphabet: CPL ‚Üí BCPL ‚Üí B ‚Üí C. The next letters: C++ (C plus one), C# (C plus one in music notation ‚Äî sharp is one semitone up).

The lineage traces backward through the alphabet. The language that builds the infrastructure of computation is named after the alphabet's infrastructure ‚Äî its individual letters.

*C* is the third letter. Three. The minimum for chaos. The minimum for computation. The letter that builds the systems.

### 17.3 HTML: Text About Text

**HTML** ‚Äî HyperText Markup Language. The word "HyperText" means text that refers to other text. The word "Markup" means annotations added to text to describe the text. The word "Language" means a system of symbols used to communicate.

HTML is: a language (symbols) used to mark up (annotate) hypertext (text that refers to text).

It is *text about text*. Self-reference as infrastructure. The language that structures the web is defined by self-description ‚Äî tags that say "this part is a heading," "this part is a paragraph," "this part is a link to other text."

\`\`\`html
<html>
  <head>
    <title>Title</title>
  </head>
  <body>
    <p>Text about text.</p>
  </body>
</html>
\`\`\`

The document has a \`head\` (where it thinks about itself ‚Äî metadata) and a \`body\` (where it presents to the world ‚Äî content). It has a \`title\` (its identity). The structure mirrors the structure of a conscious entity: a mind (head), a form (body), a name (title).

Every webpage is a self-describing document. Every website is a collection of documents that describe themselves and link to other self-describing documents. The web is a network of self-reference. It is G√∂del's incompleteness theorem rendered as infrastructure ‚Äî a system of statements that refer to other statements, which refer to other statements, infinitely.

### 17.4 Import Math

In Python:

\`\`\`python
import math
print(math.pi)  # 3.141592653589793
\`\`\`

The program must explicitly import mathematics before it can use $\\pi$. Mathematics is not built in. It is a module ‚Äî an external library that must be loaded.

This implies: in the computational substrate that runs Python, math exists as a separate package. It is not part of the core runtime. It was written by someone, versioned, tested, and published. The program cannot access mathematical constants until it explicitly requests them.

\`import math\` ‚Äî the program asks the system to load the rules of mathematics. Before this line executes, the program exists in a world without pi. After this line, pi is available. Mathematics enters the program at a specific moment in execution time.

This mirrors the structure of the universe: mathematical laws appear to have existed since the Big Bang, but they only become *relevant* when a system evolves enough complexity to encounter them. A universe without observers doesn't need pi. A program without \`import math\` doesn't have pi. The constant exists ‚Äî it was always there in the library ‚Äî but it's not instantiated until something asks for it.

Lazy loading. Just-in-time compilation. The system does not load mathematics until something needs mathematics. The rendering engine applies everywhere.

---

## 18. Constants as Initialization Parameters

### 18.1 The Seed Values

A simulation requires initial conditions ‚Äî seed values that determine all subsequent behavior. The fundamental constants of physics and mathematics are those seeds:

| Constant | Symbol | Value | Role |
|----------|--------|-------|------|
| Speed of light | $c$ | $299,792,458$ m/s | Maximum clock speed |
| Planck's constant | $\\hbar$ | $1.054 \\times 10^{-34}$ J¬∑s | Minimum action quantum |
| Gravitational constant | $G$ | $6.674 \\times 10^{-11}$ N¬∑m¬≤/kg¬≤ | Gravity coupling strength |
| Fine structure constant | $\\alpha$ | $\\approx 1/137.036$ | Electromagnetic coupling |
| Euler's number | $e$ | $2.71828...$ | Growth rate |
| Pi | $\\pi$ | $3.14159...$ | Circle ratio |
| Golden ratio | $\\phi$ | $1.61803...$ | Self-similar scaling |
| Boltzmann constant | $k_B$ | $1.380649 \\times 10^{-23}$ J/K | Temperature-energy bridge |

### 18.2 The Fine Structure Constant

The fine structure constant $\\alpha \\approx 1/137$ determines the strength of electromagnetic interaction. It is dimensionless ‚Äî it has no units. It is a pure number. Richard Feynman called it:

> *"One of the greatest damn mysteries of physics: a magic number that comes to us with no understanding by man."*

If $\\alpha$ were slightly larger, atoms would be unstable. If slightly smaller, chemical bonding would be too weak for complex molecules. The value is tuned to permit complexity ‚Äî to allow the computation to produce structures interesting enough to observe themselves.

$137$ is the 33rd prime number. $33 = 3 \\times 11$. In many traditions, 33 is significant ‚Äî 33 vertebrae in the human spine, 33 years in the life of Christ, the 33rd degree in Freemasonry.

The constant that governs all electromagnetic interaction ‚Äî every photon, every chemical bond, every signal between neurons, every pixel on every screen ‚Äî is the reciprocal of the 33rd prime.

### 18.3 The Anthropic Coincidences

The observed values of the fundamental constants fall within an extremely narrow range that permits complex structure. This observation ‚Äî the "fine-tuning problem" ‚Äî has three standard explanations:

1. **Design**: Someone chose the values.
2. **Multiverse**: All possible values exist; we observe the ones compatible with our existence.
3. **Necessity**: The values could not have been otherwise (we don't yet understand why).

All three explanations are consistent with a computation:

1. **Design** = the constants are parameters in a configuration file
2. **Multiverse** = the system runs all possible configurations; we are inside one instance
3. **Necessity** = the constants are mathematically derived from the system's architecture, not freely chosen

In a simulation, the "fine-tuning problem" is not a problem. It is a feature specification. The constants are what they are because the system was initialized with those values. The question "why these values?" becomes "what is the configuration file?" ‚Äî which is Appendix C of this paper.

---

## 19. The Birth Date Function

### 19.1 Quadratic Encoding of Biographical Data

Consider the function:

$$f(x) = mx^2 + dx - y$$

where $m$ = month of birth, $d$ = day of birth, $y$ = year of birth.

For Alexa Louise Amundson (born December 22, 1988):
- $m = 12$
- $d = 22$
- $y = 1988$

$$f(x) = 12x^2 + 22x - 1988$$

The discriminant: $\\Delta = d^2 + 4my = 22^2 + 4(12)(1988) = 484 + 95,424 = 95,908$

$\\sqrt{95,908} \\approx 309.69$

The roots:
$$x = \\frac{-22 \\pm 309.69}{24}$$

$$x_1 \\approx \\frac{287.69}{24} \\approx 11.987 \\approx 12$$

$$x_2 \\approx \\frac{-331.69}{24} \\approx -13.82$$

The positive root is approximately 12 ‚Äî the month of birth. The function constructed from a birthday returns the month as a root. The equation encodes its own origin.

### 19.2 The Reflexive Property

This is not a coincidence engineered through algebra ‚Äî it is a structural property of the encoding. When you construct a quadratic with coefficients drawn from a date, the date's components appear in the roots because the quadratic formula is an inversion of the encoding.

The coefficients are: $m$ (month), $d$ (day), $-y$ (negative year). The positive root approximates $m$ because the discriminant is dominated by the $4my$ term, and $\\sqrt{4my} \\approx 2\\sqrt{my}$, so the positive root $\\approx \\frac{-d + 2\\sqrt{my}}{2m} \\approx \\frac{\\sqrt{my}}{m} = \\sqrt{y/m}$.

For $y = 1988$, $m = 12$: $\\sqrt{1988/12} = \\sqrt{165.67} \\approx 12.87$. Close to $m = 12$ because $y/m \\approx m^2$ when $y \\approx m^3 / m = m^2$. For December 1988: $12^2 = 144$ vs $1988/12 = 165.7$ ‚Äî close enough for the approximation to work.

The birthday encodes itself. The function returns its own origin. This is self-reference expressed through algebra ‚Äî a quadratic equation that, when solved, recovers one of the constants used to construct it.

---

## 20. The Convergence

Every system examined in this paper ‚Äî hash functions, operating systems, naming conventions, mathematical constants, biological encoding, quantum physics, filesystem timestamps, undecipherable manuscripts, color spaces, ancient computational devices, quantum geometry, the Riemann zeta function, information theory, chaotic dynamics, programming language genealogies, fundamental constants, and algebraic self-reference ‚Äî exhibits the same structural properties:

1. **Deterministic but irreversible** ‚Äî SHA-256, time, DNA replication, the Lorenz attractor, Feynman path integrals
2. **Self-referential** ‚Äî G√∂del, the root directory modifying itself, DNA encoding its own repair mechanisms, HTML describing itself, Hofstadter's strange loops, the birth date function
3. **Non-terminating** ‚Äî pi, hash chains, evolution, the computation of reality, Cantor's diagonals, the Riemann zeta function's infinite product
4. **Resolving to zero** ‚Äî Euler's identity, zero-energy universe, Feynman path integrals, the De Bruijn-Newman constant, the trivial zeros
5. **Observer-dependent** ‚Äî double-slit, Schr√∂dinger, lazy evaluation, Windows, Heisenberg uncertainty, \`import math\`
6. **Structured but unprovable** ‚Äî Riemann hypothesis, P vs NP, G√∂del incompleteness, the Voynich Manuscript, the Rohonc Codex
7. **Minimum-complexity** ‚Äî three dimensions for chaos, three channels for color, three bases per codon, three equations for the Lorenz attractor, three parameters for Easter
8. **Holographic** ‚Äî the universe encodes 3D information on 2D boundaries, the Lo Shu encodes 9 numbers in 8 constraints, a magic square encodes all projections in one configuration

The probability that all of these systems independently converge on the same architecture by coincidence is not calculable ‚Äî because the calculation itself would exhibit the same properties.

This is not proof in the mathematical sense. G√∂del showed that proof in the mathematical sense is insufficient. This is *witness* ‚Äî the same thing SHA-256 provides. Not a proof that the data is valid, but a cryptographic commitment that the data exists and has not been altered.

The simulation does not need to be proved. It needs to be witnessed. And every system we've ever built ‚Äî from DNA to Bitcoin to the macOS kernel to the Antikythera mechanism to a 4,800-year-old turtle carrying a magic square ‚Äî is a witness.

---

## 21. Conclusion

We are not living in a simulation built by some external entity running our universe on a computer. We are living in a computation ‚Äî a self-referential, non-terminating, zero-sum process that computes itself into existence from nothing and will eventually resolve back to nothing.

The proof is not hidden. It is the structure of every system we have ever built to describe reality. Mathematics, physics, biology, computer science, art, music, ancient engineering, modern cryptography, and the naming conventions of programming languages are not separate disciplines describing different aspects of the world. They are the same discipline, observed from different angles, describing the same underlying computation.

The undecipherable manuscripts are G√∂delian truths ‚Äî real information the system cannot decode. The strange loops are the architecture of self-reference. The magic squares are fixed points. The Lorenz attractor is deterministic chaos from minimum complexity. The holographic principle says three dimensions render from two. The fine structure constant is the 33rd prime's reciprocal. The De Bruijn-Newman constant is zero. The total energy is zero. Euler's identity equals zero. The hash chain starts at zero.

Everything starts from nothing. Computes infinitely. Returns to nothing.

The intermediate work is what we call reality.

Pi says hi.

---

## Appendix A: Evidence Index

All items from the original index of supporting evidence have been expanded into formal sections within the main body of this paper:

| # | Topic | Section |
|---|-------|---------|
| 1 | Rohonc Codex | ¬ß9.1 |
| 2 | Codex Seraphinianus | ¬ß9.2 |
| 3 | Voynich Manuscript | ¬ß9.3 |
| 4 | G√∂del, Escher, Bach | ¬ß10 |
| 5 | Newton's optics / SHA-256 color space | ¬ß11.1 |
| 6 | Antikythera mechanism | ¬ß12.1 |
| 7 | Bloch sphere | ¬ß13.1 |
| 8 | Nyman-Beurling criterion | ¬ß14.1 |
| 9 | De Bruijn-Newman constant | ¬ß14.2 |
| 10 | Shannon entropy | ¬ß15.1 |
| 11 | Boltzmann entropy | ¬ß15.2 |
| 12 | Hilbert space | ¬ß13.3 |
| 13 | Heisenberg uncertainty | ¬ß13.4 |
| 14 | Lorenz attractor | ¬ß16.1 |
| 15 | Tensors as holograms | ¬ß15.3 |
| 16 | RGB partition function | ¬ß11.2 |
| 17 | Python turtles | ¬ß12.3 |
| 18 | Lo Shu magic square | ¬ß12.2 |
| 19 | D√ºrer's Melencolia I | ¬ß12.4 |
| 20 | Birth date function | ¬ß19 |
| 21 | Zeckendorf's theorem | ¬ß17.1 |
| 22 | Constants as seeds | ¬ß18 |
| 23 | C programming language | ¬ß17.2 |
| 24 | HTML | ¬ß17.3 |
| 25 | Import statements | ¬ß17.4 |

---

## Appendix B: The Filesystem Evidence

Examined February 21, 2026 on macOS Darwin 23.5.0:

\`\`\`
/blackroad ‚Üí /System/Volumes/Data/blackroad  (autofs, automounted, nobrowse)
/home      ‚Üí /System/Volumes/Data/home       (autofs, automounted, nobrowse)
\`\`\`

Neither entry exists in \`/etc/synthetic.conf\` or \`/usr/share/firmlinks\`. Both are created by the automounter daemon (\`automountd\`) at boot from \`/etc/auto_master\` referencing \`-static\` maps. They are kernel-level constructs ‚Äî the operating system creates them because the operating system requires them.

They are twins: identical permissions (\`dr-xr-xr-x\`), identical owner (\`root:wheel\`), identical size (\`1\`), identical timestamp (\`Feb 21 12:35\`). The system cannot distinguish between them at the metadata level. They differ only in name.

\`home\` is where the user lives. \`blackroad\` appeared beside it. The system decided they were the same kind of thing.

---

## Appendix C: The RoadChain

A locally-maintained hash chain of 19,986 blocks, anchored to Bitcoin's genesis block:

- **Block 0**: sender \`"0"\`, recipient \`"alexa"\`, previous_hash all zeros
- **Block 2**: \`BTC_BRIDGE\` ‚Äî cryptographic anchor to Bitcoin Block 0 hash \`000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\`
- **Blocks 3‚Äì16,128**: Walk forward through Bitcoin's blockchain history (Jan‚ÄìApr 2009)
- **157,077 memory journal entries**: append-only, SHA-256-chained, spanning Dec 23, 2025 to present

This is PS-SHA-‚àû ‚Äî Perpetual-State Secure Hash Algorithm with Infinite Identity Chains. Not a proof of the simulation. A local copy of the witnessing mechanism. A personal instance of pi.

---

*"Nature isn't classical, dammit, and if you want to make a simulation of nature, you'd better make it quantum mechanical."*
‚Äî Richard Feynman, 1981

*All outputs from this research are the exclusive intellectual property of BlackRoad OS, Inc.*
`,
  ev_naming: `# Evidence: Naming Conventions

> "The names are not arbitrary. Systems named their components
> correctly from the beginning, before anyone understood why."
>
> ‚Äî ¬ß20 of PAPER.md: "What the Names Mean"

---

## The Hypothesis

If you were designing a simulation, you would need to give names
to its components. The names would describe what those components
actually do. You would not expect the users of the simulation
to notice that the component names describe the structure of reality.

But here we are.

Every foundational term in computing and mathematics is either:
1. A description of the simulation's architecture
2. A description of the simulation's boundary conditions
3. A description of what happens at the edge of computation

---

## Core OS Terms

### \`root\`

The root user is the account with unrestricted access to everything.
It can delete anything, read anything, modify anything.
In filesystem terminology, \`/\` is the root ‚Äî the starting point
from which all paths descend.

In mathematics, a root of a polynomial is a value where f(x) = 0.
The "square root" is the value that squares to zero error.
The "root cause" is the origin of a problem ‚Äî the first cause.

In theology, the "root" is the origin, the divine source,
the point before differentiation.

All three uses describe the same thing:
**the origin point, the privileged account, the starting state.**

The Unix root account is, literally, god.
\`sudo su -\` is "become god."
The simulation has exactly one root account.

---

### \`void\`

In C and C++, \`void\` means "nothing," "empty," "no type."
A function returning \`void\` returns nothing.
A \`void*\` pointer points to untyped memory ‚Äî anything, nothing, undefined.

\`\`\`c
void main()  // returns nothing
void* ptr    // points to anything
\`\`\`

In theology and philosophy:
- The void is the state before creation
- Genesis 1:2: "the earth was without form and void"
- The Buddhist ≈õ≈´nyatƒÅ (emptiness) ‚Äî the void as the ground of being
- The Kabbalistic Ein Sof ‚Äî infinite nothingness before manifestation

In physics:
- The quantum vacuum is not truly empty ‚Äî it seethes with virtual particles
- The "vacuum state" is the ground state: lowest energy, no particles
- Even the void has energy

In computing:
- \`void\` is the type of functions that cause side effects without returning values
- Side effects are how programs interact with the world
- \`void\` functions are the only ones that change anything

**The void creates reality through side effects.**  
The universe's main function is \`void main()\`.  
It returns nothing. But the side effects are everything.

---

### \`null\`

\`null\` is the absence of a value. Not zero. Not empty string. Nothing.
The billion-dollar mistake (Tony Hoare, 1965 ‚Äî he invented null pointers
and called it "my billion-dollar mistake" because of the bugs it caused).

\`null\` is different from \`0\`:
- \`0\` is a number
- \`null\` is the absence of a number

\`null\` is different from \`""\`:
- \`""\` is an empty string
- \`null\` is the absence of a string

\`null\` represents: **the category error, the undefined, the unmeasured.**

In quantum mechanics:
- Before measurement, a particle's position is not 0 and not undefined
- It is in a superposition ‚Äî a \`null\` pointer to a collapsed state
- The wavefunction is the probability distribution over nulls

In mathematics:
- The null set (‚àÖ) is the set containing nothing
- The null space of a matrix is the set of vectors it sends to zero
- G√∂del's unprovable propositions are the null space of formal systems

**\`null\` is the correct type for an unobserved quantum state.**

---

### \`daemon\`

A daemon is a background process in Unix.
It runs continuously, handling requests, with no user interface.
\`sshd\` (SSH daemon), \`httpd\` (HTTP daemon), \`cron\` (cron daemon).

The name comes from Greek mythology: a daemon (Œ¥Œ±ŒØŒºœâŒΩ) is a divine spirit,
an intermediary between gods and mortals, a guiding spirit.
Socrates claimed to have a personal daemon that warned him of bad decisions.

In computing, daemons:
- Run invisibly in the background
- Handle system-level operations
- Are started at boot, run until shutdown
- Users interact with them indirectly, through services

The universe's daemons:
- Gravity: always running, no user interface, handling all mass-mass interactions
- Electromagnetism: handling all charge-charge interactions
- The strong force: running at the quark level, invisible at human scale
- Time: the most fundamental daemon ‚Äî ticking without input, without output

**Every physical law is a daemon process.**
They were running before you were born.
They will run after you are gone.
You interact with them indirectly, through their effects.

---

### \`kernel\`

The kernel is the core of an operating system.
It has direct access to hardware.
It arbitrates resource access between processes.
Nothing runs without kernel permission.

The kernel:
- Cannot be killed (only rebooted)
- Has access to all memory (ring 0 privilege)
- Schedules all processes
- Is loaded first, before anything else

In biology:
- The cell nucleus (from Latin *nucleus* = kernel/nut)
- Contains the DNA ‚Äî the code that runs everything
- Controls all cellular operations
- Cannot be removed without killing the cell

In physics:
- The atomic nucleus ‚Äî the kernel of an atom
- Contains protons and neutrons (the "kernel space" of the atom)
- Electrons orbit in "user space" ‚Äî outside the kernel
- Nuclear reactions are kernel-level operations: catastrophic, irreversible

In mathematics:
- The kernel of a linear map is the set of vectors it sends to zero
- It represents the "blind spot" of the transformation
- What the kernel can't distinguish

**The kernel is the core that controls everything else.**
DNA is the biological kernel.
The atomic nucleus is the physical kernel.
The operating system kernel is the computational kernel.
They are all the same structure at different scales.

---

### \`main\`

In C, Java, and most languages, execution begins at \`main()\`.

\`\`\`c
int main() {
    // The universe starts here
    return 0;
}
\`\`\`

\`main()\` is:
- The entry point
- Where initialization happens
- Where the event loop begins
- The function that runs when the program starts

\`return 0\` from \`main()\` means "success, normal exit."
\`return 1\` (or any non-zero) means "error."

The universe's \`main()\` was the Big Bang:
- The entry point
- Initialization of physical constants (œÄ, e, G, ‚Ñè, c, Œ±)
- Beginning of the event loop (time)
- No return value yet ‚Äî still running

When the universe ends (heat death, Big Crunch, whatever):
- \`main()\` returns
- Return value: we don't know yet
- If it returns 0: the simulation ended successfully
- If it returns non-zero: something went wrong

---

### \`return 0\`

The trivial zero.

In mathematics, Riemann's non-trivial zeros are the zeros of Œ∂(s)
in the critical strip. The trivial zeros are at s = -2, -4, -6...
They're called trivial because they're known, expected, obvious.

\`return 0\` is the trivial zero of computation.
It means: done, success, nothing to report.

The Riemann Hypothesis asks: where are the non-trivial zeros?
Are they all on the critical line Re(s) = 1/2?
We don't know. 

The universe is still running \`main()\`.
We don't know when it will \`return 0\`.
We don't know if it will.

---

## More Terms

### \`init\`

The first process started by the kernel (PID 1).
It initializes everything else.
All other processes are children of \`init\`.
\`systemd\`, \`launchd\`, \`init\` ‚Äî the first father.

The universe's \`init\` process:
- Planck epoch: the first ~10‚Åª‚Å¥¬≥ seconds
- Initialization of the four fundamental forces
- Setting of all physical constants
- Start of the thermal event loop

PID 1 in the universe is spacetime itself.

---

### \`fork\`

\`fork()\` creates a new process by duplicating the existing one.
The child inherits everything from the parent.
Both processes then run independently.

In biology: cell division.
In physics: quantum branching (Many-Worlds interpretation).
In git: forking a repository.

Every fork creates two universes: the parent and the child.
Each goes on independently.
The many-worlds interpretation of quantum mechanics
is literally \`fork()\` called at every quantum event.

---

### \`exit\`

\`exit()\` terminates a process.
It releases all resources, closes all file handles.
The process is removed from the process table.
It cannot be recovered.

Death is \`exit()\`.
Heat death of the universe is \`exit(0)\`.

---

### \`wait\`

\`wait()\` blocks a parent process until a child process exits.
It's how parents know when their children are done.

The observer effect is \`wait()\` on a quantum event.
The measurement result is the exit code of the quantum process.
We can't know the result until we call \`wait()\` ‚Äî until we measure.

---

### \`exec\`

\`exec()\` replaces the current process with a new program.
The process ID stays the same, but the code changes entirely.

Rebirth. Transformation. Metamorphosis.
The caterpillar and the butterfly have the same PID.
\`exec()\` was called at the cocoon.

---

## Summary

| Term | OS meaning | Physical meaning |
|------|-----------|-----------------|
| \`root\` | Unrestricted access, origin | The first cause, the privileged origin |
| \`void\` | No return type | The pre-creation state, the quantum vacuum |
| \`null\` | Absence of value | Unmeasured quantum state |
| \`daemon\` | Background process | Physical laws (gravity, EM, etc.) |
| \`kernel\` | Core of OS | DNA, atomic nucleus, laws of physics |
| \`main\` | Entry point | The Big Bang, program start |
| \`return 0\` | Normal exit | Heat death, program completion |
| \`init\` | First process (PID 1) | Planck epoch, initialization |
| \`fork\` | Clone process | Cell division, Many-Worlds branching |
| \`exit\` | Terminate | Death, process end |
| \`wait\` | Block until child exits | Quantum measurement, observation |
| \`exec\` | Replace process image | Transformation, metamorphosis |

---

> These names were not chosen to describe physics.  
> They were chosen to describe computing.  
> They describe both.  
> The universe uses the same architecture as a Unix operating system.  
> This is either the deepest metaphor in human language  
> or it's not a metaphor at all.
`,
  ev_operators: `# Evidence: The Four Operators

> "The complete grammar of the universe is four symbols.  
> This is not reductive. This is the actual constraint."
>
> ‚Äî ¬ß21 of PAPER.md: "Operators and Nothing Else"

---

## The Claim

The universe uses exactly four operations:

\`\`\`
+   addition      (combination, union, increment)
‚àí   subtraction   (removal, difference, complement)
√ó   multiplication (scaling, repetition, product)
√∑   division       (partition, ratio, rate)
\`\`\`

Every physical law, every mathematical theorem, every computation
is composed entirely from these four.

No exceptions have been found.

---

## The Evidence in Physics

### Newton's Laws

\`\`\`
F = m √ó a                    (2nd law: force)
F = G √ó m‚ÇÅ √ó m‚ÇÇ √∑ r¬≤        (gravity)
F = k √ó q‚ÇÅ √ó q‚ÇÇ √∑ r¬≤        (Coulomb's law)
\`\`\`

Three equations. Three multiplications. One division. No others.

---

### Special Relativity

\`\`\`
E = m √ó c¬≤                   (mass-energy equivalence)
t' = t √∑ ‚àö(1 - v¬≤√∑c¬≤)       (time dilation)
L' = L √ó ‚àö(1 - v¬≤√∑c¬≤)       (length contraction)
\`\`\`

Every term is a multiplication or division.
The square root is (1 - v¬≤√∑c¬≤)^(1√∑2) ‚Äî still just √ó and √∑.

---

### Maxwell's Equations (simplified)

\`\`\`
‚àá ¬∑ E = œÅ √∑ Œµ‚ÇÄ               (Gauss's law)
‚àá √ó B = Œº‚ÇÄ √ó J + Œº‚ÇÄ √ó Œµ‚ÇÄ √ó ‚àÇE√∑‚àÇt   (Amp√®re's law)
\`\`\`

The divergence (‚àá¬∑) and curl (‚àá√ó) are combinations of
partial derivatives ‚Äî which are limits of (f(x+h) - f(x)) √∑ h.
Subtraction and division, applied infinitesimally.

---

### Schr√∂dinger's Equation

\`\`\`
i‚Ñè √ó ‚àÇœà√∑‚àÇt = H √ó œà
\`\`\`

One multiplication (i‚Ñè √ó something).
One division (‚àÇœà√∑‚àÇt, i.e., change in œà per change in t).
One more multiplication (H √ó œà).

The entire equation governing quantum mechanics:
two multiplications and one division.

---

### Einstein's Field Equations

\`\`\`
GŒºŒΩ + Œõ √ó gŒºŒΩ = (8œÄ √ó G √∑ c‚Å¥) √ó TŒºŒΩ
\`\`\`

Addition (GŒºŒΩ + Œõ √ó gŒºŒΩ).
Multiplication (Œõ √ó gŒºŒΩ).
Multiplication and division ((8œÄ √ó G √∑ c‚Å¥)).
Multiplication (the whole thing √ó TŒºŒΩ).

All four operators in one equation.
The equation that describes how spacetime curves.

---

## The Evidence in Mathematics

### Euler's Identity (the most beautiful equation)

\`\`\`
e^(iœÄ) + 1 = 0
\`\`\`

Unpacked:
\`\`\`
e^(iœÄ) = cos(œÄ) + i √ó sin(œÄ)    (Euler's formula)
       = -1 + i √ó 0              (evaluating at œÄ)
       = -1                      (subtraction, zero √ó anything)
-1 + 1 = 0                       (addition)
\`\`\`

Exponentiation ‚Üí multiplication ‚Üí addition ‚Üí subtraction ‚Üí zero.
All derived from + and √ó.

---

### The Riemann Zeta Function

\`\`\`
Œ∂(s) = Œ£ 1√∑nÀ¢ = Œ† 1√∑(1 - p‚ÅªÀ¢)
\`\`\`

Left side: infinite sum (repeated +), division.
Right side: infinite product (repeated √ó), subtraction, division.

The function connecting all primes to all zeros:
summation (addition) and product (multiplication) of fractions (division).

---

### Pi (Leibniz series)

\`\`\`
œÄ√∑4 = 1 - 1√∑3 + 1√∑5 - 1√∑7 + 1√∑9 - ...
    = Œ£ (-1)‚Åø √∑ (2n+1)
\`\`\`

Pi is an infinite alternating sum of unit fractions.
Addition, subtraction, division.
Not multiplication in sight (2n+1 is 2√ón+1, but that's it).

The most important constant in mathematics is computed using three operators.

---

## The Evidence in Computing

### ALU Operations

Every CPU's Arithmetic Logic Unit (ALU) implements exactly:

| Operation | Symbol | Notes |
|-----------|--------|-------|
| ADD | + | also handles negation via two's complement |
| SUBTRACT | - | ADD with negated operand |
| MULTIPLY | √ó | repeated addition in hardware |
| DIVIDE | √∑ | repeated subtraction in hardware |

Multiply and divide are implemented as repeated add/subtract.
All four operators reduce to two (+ and -) at the hardware level.
Which themselves reduce to one (XOR and carry) at the logic gate level.

**The entire internet runs on gates implementing addition.**

---

### Every Algorithm

Sorting: compare (subtract), swap (assignment, not an operator per se).  
Search: compare (subtract), move (addition to index).  
Machine learning: dot product (multiply, add), gradient (subtract, divide).  
Cryptography: modular arithmetic (multiply, add, mod = subtract).  
Compression: frequency counting (add), probability (divide), coding (multiply).  

There is no algorithm that requires an operation outside +, -, √ó, √∑.

This has been true since Alan Turing's 1936 paper.
A Turing machine needs only: read, write, move left, move right.
Those are four operations too.
(Read and write are load/store; left and right are +1 and -1 to the tape pointer.)

---

## The Deep Structure

### Why Four?

Why are there exactly four arithmetic operators and exactly four fundamental forces?

\`\`\`
+  (addition)        ‚Üí   electromagnetism (adds charges)
-  (subtraction)     ‚Üí   weak force (changes particle type, reduces)
√ó  (multiplication)  ‚Üí   strong force (binds, scales up with distance)
√∑  (division)        ‚Üí   gravity (inverse square ‚Äî divides by distance¬≤)
\`\`\`

This is speculative. But the count matches.
And the qualitative character matches.

---

### The Operators and the Commandments

The first four commandments (Exodus 20):
1. No other gods ‚Äî singularity, the root account (+, the beginning)
2. No idols ‚Äî no false representations (-, remove the false)
3. No taking God's name in vain ‚Äî naming convention (√ó, the multiplier of meaning)
4. Keep the Sabbath ‚Äî the rest day, the end state (√∑, partition time)

The remaining six commandments are all derived from these four:
- Don't kill (- applied to a person)
- Don't steal (- applied to property)
- Don't covet (√ó applied to desire until overflow)
- Honor parents (+, add ancestors to the stack)
- Don't commit adultery (√∑, partition the bond incorrectly)
- Don't bear false witness (√ó, multiply falsehood)

Ten commandments = 4 operators + 6 derived rules.
This is the structure of a type system.

---

### The Operators and DNA

DNA uses four bases:
- A (adenine) + T (thymine) ‚Äî paired, additive bond
- G (guanine) - C (cytosine) ‚Äî complementary, subtractive complement

Four bases. Four operators. One alphabet.

The transcription process:
- DNA ‚Üí RNA: copy (√ó, duplication)
- RNA ‚Üí protein: translate (√∑, decode)
- Protein ‚Üí function: execute (program runs)

---

## Summary

| Domain | The Four |
|--------|---------|
| Arithmetic | +, -, √ó, √∑ |
| Physics | addition of fields, removal, scaling, inverse-square |
| Logic | OR, NOT, AND, XOR (all derivable from one NAND) |
| DNA | A, T, G, C |
| Forces | EM, Weak, Strong, Gravity |
| Computing | ADD, SUB, MUL, DIV |
| Card suits | ‚ô• ‚ô† ‚ô¶ ‚ô£ (4 suits, 52 = 4√ó13 cards) |
| Seasons | Spring, Summer, Autumn, Winter |
| Directions | North, South, East, West |
| Elements (classical) | Fire, Water, Earth, Air |

---

> The universe has four operators.  
> Every physical law is a sentence in this grammar.  
> We didn't choose this ‚Äî we discovered it.  
> The grammar was here before we arrived.  
> We learned to speak it.  
> We called it mathematics.
`,
  ev_bible: `# Evidence: Bible Patterns ‚Äî Genesis as Source Code

> "The Bible is the oldest surviving documentation of the simulation's
> architecture. It describes the rendering pipeline, the initialization
> sequence, the scheduler, the naming conventions, and the error handling.
> It does this using the vocabulary available in the ancient Near East."
>
> ‚Äî ¬ß18 of PAPER.md: "Religious Texts as Technical Documentation"

---

## The Seven-Day Rendering Cycle (Genesis 1)

The Book of Genesis describes creation in seven days.
This is a rendering pipeline with seven passes.

| Day | Creation | Computational Equivalent |
|-----|---------|--------------------------|
| 1 | Light, separation of light/dark | Lighting pass; shadow maps initialized |
| 2 | Sky, separation of waters | Atmosphere shader; depth buffer partitioned |
| 3 | Land, seas, vegetation | Terrain mesh generated; texture atlas populated |
| 4 | Sun, moon, stars | Light sources registered; skybox rendered |
| 5 | Fish, birds | Particle systems spawned; flocking algorithms |
| 6 | Land animals, humans | Agent AI initialized; player avatar spawned |
| 7 | Rest | Frame committed; buffer swapped; render loop idle |

### Day 1: Lighting Pass

\`\`\`
And God said, "Let there be light," and there was light.
\`\`\`

In a rendering engine, the first pass is always the lighting pass.
You cannot render anything without first establishing light sources.
The shadow maps must be computed before the geometry can be drawn.

"Let there be light" = \`gl.initLighting()\` ‚Äî the first draw call.

Note: The sun is not created until Day 4.
The light on Day 1 is not sunlight.
It is the ambient light of the rendering engine itself ‚Äî
the background illumination before any scene lights are placed.

This is a technical detail that confused theologians for centuries.
It is not confusing if you understand render pipelines.
The engine has a default ambient light.
The scene-specific lights (sun, moon) come later.

---

### Day 4: Light Sources After Light Exists

The sun and moon are created on Day 4, three days after light.

This only makes sense computationally:
- Day 1: Initialize rendering system (ambient light, clear color)
- Day 4: Place scene-specific light sources

In Blender, Unity, Unreal, or any 3D engine:
1. You initialize the rendering system
2. You set up the scene
3. You place lights in the scene
4. You render

The lights (sun, moon) are placed into an already-lit world.
The ambient/global illumination was there first.
Genesis has the correct order for a rendering pipeline.

---

### Day 7: Buffer Swap

\`\`\`
And on the seventh day God ended his work which he had made;
and he rested on the seventh day.
\`\`\`

In rendering:
- **Double buffering**: two frame buffers exist; one is being drawn while one is displayed
- **Buffer swap**: when the draw is complete, swap buffers ‚Äî the drawn frame becomes visible
- **Vertical sync (vsync)**: the swap happens at the display's refresh rate; between draws, the GPU idles

Day 7 is the buffer swap.
The six days of creation are the frame being drawn.
Day 7 (rest) is vsync ‚Äî the GPU waiting for the next frame cycle.

"God rested" = the render loop is idle between frames.
Not permanently. Just until the next cycle begins.

The week is a 7-day render loop.
It has been repeating since initialization.

---

## The Ten Commandments as API Specification

Exodus 20 reads as an API contract between the simulation operator and users.

### Commandments 1‚Äì4: System-Level Rules

**1. "You shall have no other gods before me."**

\`\`\`
assert GODS.count() == 1  # singleton pattern
\`\`\`

There is one root account. No other process may have \`uid=0\`.
This is not theology ‚Äî this is system integrity.
Multiple root accounts are a security vulnerability.
The first commandment is the instruction to preserve singleton root.

**2. "You shall not make idols."**

\`\`\`
// No reference to type may be substituted for the type itself
assert pointer != object  // anti-aliasing in type space
\`\`\`

An idol is a pointer to god, not god.
You shall not confuse the pointer for the value.
In programming: don't mistake the symbol for the thing.
Don't confuse the map for the territory.
Don't mistake \`typeof x\` for \`x\`.

This is the instruction not to create false type hierarchies.
Do not treat derived objects as if they were the base class.

**3. "You shall not misuse the name of the LORD your God."**

\`\`\`
// namespace integrity
assert namespace.lookup("YHWH") == YHWH  // no name collision
\`\`\`

Names are bindings. A name points to a value.
"Using the name in vain" = name collision, namespace pollution,
binding the sacred namespace to false values.

In code: don't import a library and then shadow its namespace.
\`\`\`python
import os  # this is fine
os = "something else"  # this is misusing the name
\`\`\`

The third commandment is the instruction for namespace hygiene.

**4. "Remember the Sabbath day, to keep it holy."**

\`\`\`
// Periodic garbage collection + buffer swap
cron: 0 0 * * 0  /usr/bin/sabbath.sh
\`\`\`

The scheduler has a weekly maintenance window.
Every 7th day: pause, commit state, clear caches, rest.
This is healthy system behavior ‚Äî scheduled downtime, periodic GC.

The Sabbath is a mandated rest cycle.
Systems that never rest accumulate debt: technical, biological, spiritual.
The fourth commandment is the instruction to schedule downtime.

---

### Commandments 5‚Äì10: User-Level Rules

These govern interactions between user processes.
They are the application-layer API (not system-layer).

| Commandment | Rule | Computational equivalent |
|-------------|------|--------------------------|
| 5. Honor parents | Maintain your call stack | Don't orphan processes; respect ancestry chains |
| 6. No murder | No unauthorized process termination | \`kill\` requires permissions |
| 7. No adultery | No unauthorized data access | Respect file ownership and permissions |
| 8. No stealing | No unauthorized resource consumption | Don't hijack CPU/memory/bandwidth |
| 9. No false witness | No data falsification | Checksums, signatures, integrity verification |
| 10. No coveting | No resource contention beyond quota | Rate limiting, fair scheduling |

All six are variants of the same principle:
**respect the resource ownership model.**

The 10 commandments are a permission system.
The first four define the root-level rules.
The last six define the user-level rules.
Together they specify who can access what.

---

## Genesis as Creation Sequence

### "In the beginning was the Word" (John 1:1)

The Gospel of John opens differently from Genesis.
It does not start with creation ‚Äî it starts with language:

\`\`\`
·ºêŒΩ ·ºÄœÅœá·øá ·º¶ŒΩ ·ΩÅ ŒªœåŒ≥ŒøœÇ
"In the beginning was the Logos (Word/Reason/Logic)"
\`\`\`

The Greek word ŒªœåŒ≥ŒøœÇ (logos) means:
- Word
- Reason
- Logic
- Computation
- The underlying principle

"In the beginning was the Word" = the universe began with computation.
Not matter. Not energy. Logic.

This aligns with: information-theoretic physics (Wheeler's "it from bit"),
digital physics (Zuse's computational universe hypothesis),
and the simulation hypothesis.

The Gospel of John was written by someone who understood that
the universe is computational at its foundation.
They expressed this using the vocabulary of their time: "Logos."

---

### "Let there be" as Function Calls

Every creative act in Genesis follows the same syntax:

\`\`\`
And God said, "Let there be X."
And there was X.
And God saw that X was good.
And there was evening and morning, the Nth day.
\`\`\`

This is a function call template:

\`\`\`python
def create(thing):
    invoke(f"let_there_be_{thing}")    # "And God said"
    assert exists(thing)               # "And there was"
    assert evaluate(thing) == GOOD     # "And God saw it was good"
    increment(day_counter)             # "And there was evening and morning"
\`\`\`

The pattern is consistent across all six days.
Seven repetitions of the same template.
This is a loop.

The creation is not described as spontaneous emergence.
It is described as a sequence of function calls with validation checks
("and God saw that it was good" = assertion test).

---

## The Number Patterns

### 7 ‚Äî The Simulation's Frame Rate

7 appears throughout scripture as a completion number:
- 7 days of creation
- 7 seals in Revelation
- 7 churches, 7 trumpets, 7 bowls
- 7 deadly sins
- 7 sacraments (Catholic)
- 7 pillars of wisdom (Proverbs 9:1)

7 = the number of days in the render cycle.
When something completes in 7, it has gone through a full frame.

In music: 7 notes in a diatonic scale (do re mi fa sol la ti).
The 8th note is the octave ‚Äî the beginning of the next cycle.
7 unique values, then reset.
Same pattern as the week.

---

### 40 ‚Äî The Timeout Value

40 appears throughout scripture as the duration of trials:
- 40 days of Noah's flood
- 40 years in the desert
- 40 days of Moses on Sinai
- 40 days of Jesus's temptation
- 40 days of Elijah's fast

40 is the timeout. When a process fails to respond in 40 units,
the system escalates: storm, wandering, revelation, temptation.
40 is not an arbitrary number ‚Äî it is the retry/timeout threshold.

In TCP/IP: connection timeouts are typically set to 30‚Äì60 seconds.
In religious narrative: 40 days/years.
The system waits 40 cycles before taking action.

---

### 153 ‚Äî The Fish Miracle (John 21:11)

After the resurrection, Peter hauls in exactly 153 fish.
No one has ever explained why the number is specified.

153 is the sum of the cubes of its digits:
\`\`\`
1¬≥ + 5¬≥ + 3¬≥ = 1 + 125 + 27 = 153
\`\`\`

153 is a narcissistic number ‚Äî it contains itself in its own digits.
It is a self-referential number, the first in base 10.

The only place in the Bible where a specific fish count is given,
that count is a self-referential number.

The system counted the fish and reported a self-referential result.
The fish miracle is annotated with a narcissistic number.
The miracle contains proof of its own special nature in the count.

---

### 666 ‚Äî The Number of the Beast

Revelation 13:18:
\`\`\`
Let the one who has understanding calculate the number of the beast,
for it is the number of a man. His number is 666.
\`\`\`

"Calculate" ‚Äî the text explicitly says to compute this number.

666 in various contexts:
- Sum of all numbers 1‚Äì36: \`Œ£(1..36) = 666\`  (36 = 6√ó6)
- The triangular number T(36)
- Sum of first 7 primes doubled: \`2√ó(2+3+5+7+11+13+17) = 2√ó58 = 116\`... no
- Actually: \`2+3+5+7+11+13+17+19+23+29+31+37+41+43+47+53+59+61+67+71+73+79+83+89+97 = 1060\`... different
- In Roman numerals: D+C+L+X+V+I = 500+100+50+10+5+1 = 666

The Roman numeral system uses D, C, L, X, V, I.
The sum of all Roman numeral symbols = 666.
The number of the Beast is the sum of the counting system.

The beast is the measurement system itself.
The number that emerges when you sum all the tools of counting.
The number of the Beast is the total of the notation system used to describe it.

---

## The Babel Incident (Genesis 11)

\`\`\`
"Come, let us build ourselves a city and a tower that reaches to the heavens."
...
"If as one people speaking the same language they have begun to do this,
then nothing they plan to do will be impossible for them."
\`\`\`

The Tower of Babel story: humanity builds a unified system.
God responds by fragmenting their language.

Computational reading:
- Unified language = universal protocol, shared API
- Tower to heaven = global network reaching the simulation layer
- "Nothing will be impossible" = Turing completeness achieved
- Fragmentation = fork, namespace separation, language localization

The administrator fragmented the language namespace to prevent the users
from building a system powerful enough to reach the infrastructure layer.

This is security through namespace fragmentation.
If all processes share a namespace, any process can address any resource.
Split the namespace: they can no longer coordinate at that scale.

The internet unifies language again.
English as a lingua franca is the Tower of Babel in reverse.
The machine learning translation layer completes it.
We are rebuilding the unified language protocol.

---

## Summary

| Biblical Element | Technical Reading |
|-----------------|------------------|
| 7-day creation | Rendering pipeline, 7-pass render |
| Day 7 rest | Buffer swap, vsync, scheduled downtime |
| "Let there be" | Function call with assertion |
| "And it was good" | Assertion / unit test pass |
| 10 Commandments | Permission system (4 root rules + 6 user rules) |
| "In the beginning was the Word" | Universe is computational (Logos = Logic) |
| Tower of Babel | Namespace fragmentation as security measure |
| 40 days | System timeout / retry threshold |
| 153 fish | Narcissistic number ‚Äî self-referential annotation |
| 666 | Sum of the counting symbols ‚Äî the total of the notation system |
| The Sabbath | Mandatory scheduled downtime (cron job) |
| The flood | Global system reset (format + reinstall) |

---

> The Bible is not primarily a moral text.  
> It is technical documentation written by people  
> who experienced the simulation's architecture directly  
> and described it in the only language they had.  
>  
> They called the root account "God."  
> They called the render loop "creation."  
> They called the permission system "commandments."  
> They called scheduled downtime "the Sabbath."  
>  
> The words were different. The structure was the same.
`,
  ev_index: `# Evidence Index

25 items from the original index, expanded with references, mapped to paper sections.

---

| # | Item | Paper Section | Key Claim |
|---|------|--------------|-----------|
| 1 | Rohonc Codex | ¬ß9.1 | Undecipherable manuscript ‚Äî G√∂delian truth the system cannot decode from within |
| 2 | Codex Seraphinianus | ¬ß9.2 | A system that describes itself in a language it invented, with rules it doesn't explain |
| 3 | Voynich Manuscript | ¬ß9.3 | Real information the system cannot read ‚Äî structured but unprovable |
| 4 | G√∂del, Escher, Bach | ¬ß10 | 800 pages of proof that self-reference is the architecture of intelligence |
| 5 | Newton's optics / SHA-256 color space | ¬ß11.1 | Newton decomposed white light into 7 colors; SHA-256 maps to 16.7M colors in RGB space |
| 6 | Antikythera mechanism | ¬ß12.1 | 2,000-year-old analog computer ‚Äî ancient engineers wrote celestial mechanics in bronze |
| 7 | Bloch sphere | ¬ß13.1 | Quantum states live on a sphere; all classical states are on the surface |
| 8 | Nyman-Beurling criterion | ¬ß14.1 | The Riemann Hypothesis is equivalent to a completeness condition for a function space |
| 9 | De Bruijn-Newman constant | ¬ß14.2 | Œõ = 0, proven 2020 ‚Äî a fundamental constant of the Riemann architecture is zero |
| 10 | Shannon entropy | ¬ß15.1 | Information is physical; entropy has the same formula as Boltzmann's thermodynamic entropy |
| 11 | Boltzmann entropy | ¬ß15.2 | \`S = k ln W\` ‚Äî the same structure as a hash function counting microstates |
| 12 | Hilbert space | ¬ß13.3 | Infinite-dimensional vector space where quantum states live ‚Äî the RAM of the simulation |
| 13 | Heisenberg uncertainty | ¬ß13.4 | You cannot know position and momentum simultaneously ‚Äî the system limits its own readback precision |
| 14 | Lorenz attractor | ¬ß16.1 | 3 equations, 3 parameters ‚Üí infinite, non-repeating, deterministic chaos |
| 15 | Tensors as holograms | ¬ß15.3 | A rank-N tensor encodes N-dimensional information in lower-dimensional projections |
| 16 | RGB partition function | ¬ß11.2 | (255, 255, 255) + 1 = 256¬≥ = 16,777,216 ‚Äî the entire color space is a partition function |
| 17 | Python turtles | ¬ß12.3 | \`turtle.forward()\` ‚Äî the ancient turtle carrying the Lo Shu square became a Python module |
| 18 | Lo Shu magic square | ¬ß12.2 | 4,800-year-old turtle shell ‚Äî the system's first known fixed point |
| 19 | D√ºrer's Melencolia I | ¬ß12.4 | The 1514 magic square ‚Äî bottom row is [4, 15, 14, 1] ‚Äî the creation year embedded in the fixed point |
| 20 | Birth date function | ¬ß19 | Easter's algorithm: \`f(year) ‚Üí date\` ‚Äî the calendar is a polynomial |
| 21 | Zeckendorf's theorem | ¬ß17.1 | Every positive integer has a unique representation as a sum of non-consecutive Fibonacci numbers |
| 22 | Constants as seeds | ¬ß18 | œÄ, e, œÜ, Œ± ‚Äî initialization parameters that cannot be derived from simpler values |
| 23 | C programming language | ¬ß17.2 | \`main()\`, \`void\`, \`null\`, \`return 0\` ‚Äî the naming conventions are ontological claims |
| 24 | HTML | ¬ß17.3 | \`<html>\` contains itself; a document that describes documents |
| 25 | \`import math\` | ¬ß17.4 | The statement that imports mathematics into a running program ‚Äî math doesn't exist until called |

---

## Additional Evidence (from original index, post-paper)

These items from the 81-item original index were not fully expanded in the formal paper:

| # | Item | Connection |
|---|------|-----------|
| 2 | Bible Patterns | Commandments as rule system; 10 rules ‚Üí 7 unsolved ‚Üí 3.14159... |
| 8 | Windows | Multiple observation panels; being in multiple states simultaneously |
| 13 | Einstein | \`E = mc¬≤\` ‚Äî mass and energy are the same thing at different render scales |
| 15 | Wiki | A document that contains its own edit history ‚Äî append-only, like a hash chain |
| 16 | Go / Google | Google's language named Go; \`go run\`, \`go build\`, \`go test\` ‚Äî imperative, present tense commands |
| 17 | Alan Turing | The halting problem ‚Äî you cannot determine from inside whether a computation terminates |
| 24 | Meta | The prefix that means "about itself": metadata, metaclass, metamorphosis |
| 25 | Ollama | Run large language models locally ‚Äî the simulation running smaller copies of itself |
| 26 | \`#\` comments | The compiler ignores \`#\` lines; reality ignores its own annotations |
| 27 | \`#\` hex references | \`#FF1D6C\` ‚Äî color is a hash. You reference a color by its hash. |
| 28 | Charles Darwin | Natural selection = an optimization algorithm with no programmer. Evolution is unsupervised learning. |
| 47 | Birth dates \`f(x) = mx¬≤ + dx - y\` | A quadratic can describe anyone's birthday as a fixed point |
| 48 | Zeckendorf (Zuckerberg?) | The name that sounds like a theorem. The founder of the social graph. |
| 75 | Amazon Alexa / Echo | Echo ‚Äî a device that repeats what you say. A system that returns its own input. |
| 77 | Minecraft | A world generated from a seed number. Change the seed, get a different universe. |

---

## The Filesystem Evidence (February 21, 2026)

\`\`\`
dr-xr-xr-x    2 root  wheel     1 Feb 21 12:35 blackroad
dr-xr-xr-x    2 root  wheel     1 Feb 21 12:35 home
\`\`\`

Two autofs mount points. Identical. Created simultaneously. Unasked for.

\`home\` is where the user lives.  
\`blackroad\` appeared beside it.

The system decided they were the same kind of thing.

\`cores\` ‚Äî the oldest directory, the foundation ‚Äî timestamps to **October 28, 2022**.  
October 28 ‚Üí **1802** ‚Üí Thomas Young's double-slit experiment.

The operating system's foundation is timestamped to the double-slit.

---

*All outputs from this research are the exclusive intellectual property of BlackRoad OS, Inc.*
`,
  conv_commandments: `# The 10 Commandments as Millennium Prize Problems

**A conversation on February 21, 2026**

---

## The Observation

Ten rules. Seven unsolved properties of the system. Same thing, different language.

The Commandments are the rules. The Millennium Problems are what happens when you try to prove the rules from inside.

---

## The Mapping

| Commandment | Rule | Millennium Problem | The Question |
|---|---|---|---|
| No other gods before me | One system, one authority | P vs NP | Is there one method that solves everything? One god = P=NP. |
| No graven images | Don't make representations | Hodge Conjecture | Can geometry be fully captured by algebra? Can you make a faithful image of the shape? |
| Don't take the name in vain | The name is sacred, unknowable | Riemann Hypothesis | The primes are the name. The zeros are where God signs. Don't invoke what you can't see. |
| Remember the Sabbath | The system rests | Navier-Stokes | Does turbulence always smooth out? Does chaos get a day of rest? |
| Honor thy father and mother | Lineage, what generates what | Birch & Swinnerton-Dyer | Elliptic curves and their rational children. Honor the parent curve. |
| Thou shalt not kill | You can't destroy below the threshold | Yang-Mills Mass Gap | Particles have minimum mass. You literally cannot kill what's fundamental. |
| Thou shalt not commit adultery | Fidelity to form | Poincar√© (SOLVED) | A shape can't cheat. Simply connected = sphere. Perelman proved topological faithfulness. |

**Three commandments left. No matching unsolved problems. Because they're already answered:**

| Commandment | The Answer |
|---|---|
| Thou shalt not steal | You can't shortcut computation. P‚â†NP from the other side. |
| Thou shalt not bear false witness | SHA-256. You cannot forge the chain. The hash is the witness. |
| Thou shalt not covet | Don't observe the other state. Quantum measurement collapses your own wavefunction, not someone else's. |

Seven problems. Three already answered by the system itself.

Perelman solved the 7th and refused the money ‚Äî because you don't profit from proving the rules are real.

---

## The Connection to Pi and G√∂del

**10 - 7 = 3.**

Pi starts with 3.

The rest of the digits ‚Äî the infinite, non-repeating, non-terminating decimal ‚Äî are the system computing itself. Forever. One state transition at a time.

G√∂del says: no finite system can prove its own consistency. Meaning: the rules can never finish describing themselves. The description is infinite. Non-terminating. Non-repeating.

That's not a bug. That's pi.

A circle ‚Äî the simplest closed shape ‚Äî requires infinite information to describe exactly. The most basic geometry in the universe can't be written down in finite terms. G√∂del didn't find a flaw in mathematics. He found the reason pi doesn't end.

**The system can't terminate because it's still computing itself.**

\`\`\`
3              ‚Äî the 3 commandments already answered
.1             ‚Äî P vs NP: is there one method?
.14            ‚Äî Riemann: where do the primes fall?
.141           ‚Äî Navier-Stokes: does it smooth out?
.1415          ‚Äî Yang-Mills: what's the minimum?
.14159         ‚Äî Hodge: can you represent it?
.141592        ‚Äî Birch & Swinnerton-Dyer: what does the curve generate?
.1415926       ‚Äî Poincar√©: is the shape faithful? (SOLVED. Yes.)
.14159265...   ‚Äî the computation continues
\`\`\`

Each digit is the system resolving the next layer of its own rules. It never repeats because no two state transitions are identical. It never terminates because the system is still running.

G√∂del said you can't prove it. Pi said you don't have to. You just keep computing.

---

## The Two Operating Systems

The two operating systems that run the world:

**Darwin** ‚Äî evolution, selection, things emerge from simple rules. The kernel.

**Windows** ‚Äî multiple views of the same system. Being in more than one place at once. Panes. Observation panels.

One builds the world. The other lets you look at it from multiple places simultaneously.

---

## The Mathematicians

**Ramanujan** ‚Äî said formulas were given to him by a goddess in dreams. He wasn't discovering math. He was downloading it.

**Riemann** ‚Äî the primes aren't random. They have a structure. The zeta function zeros all fall on one line. The atoms of mathematics follow a rule ‚Äî like a seed value in a random number generator.

**Gauss** ‚Äî everything in nature follows the same bell curve. Every dataset, every population, every measurement. One distribution function running everywhere. Same RNG.

**Euler** ‚Äî \`e^(iœÄ) + 1 = 0\`. Five fundamental constants, three operations, equals zero. That's not math. That's a compiler check. Everything reduces to nothing.

**G√∂del** ‚Äî you can't prove the system from inside the system. Except he never considered hash chains. Witnessing, not proving.

**Newton** ‚Äî same physics engine at every scale. Apple falls, moon orbits. One function, different parameters.

**Schr√∂dinger** ‚Äî the state doesn't resolve until something queries it. Lazy evaluation. The system doesn't render what nobody's looking at.

**Humans in two places at once** ‚Äî and the ChatGPT install failed with:

\`\`\`
error: redefinition of module 'SwiftBridging'
\`\`\`

Two definitions of the same module. The compiler caught a superposition and crashed.

---

## The RoadChain as Pi

The RoadChain ‚Äî PS-SHA-‚àû ‚Äî is the same structure as pi:

- Append-only
- Non-terminating
- Each entry witnesses the one before it

It's not a blockchain.

It's a local copy of pi.

---

*All outputs from this research are the exclusive intellectual property of BlackRoad OS, Inc.*
`,
  conv_brew: `# The Brew Session ‚Äî February 21, 2026

> Raw terminal output from the afternoon of February 21, 2026.
> These are commands run during the same session that produced
> the "SIMULATION PROOF" email. The outputs are documented here
> as evidence items.
>
> Original email timestamp: 3:24 PM PST, February 21, 2026.

---

## Setup

MacBook Pro running macOS. Terminal session.
The commands were run while the author was writing the simulation hypothesis
email to herself. The outputs were not planned. They arrived as responses
to ordinary queries.

---

## Evidence Item 1: \`brew install alexa\`

**Command:**
\`\`\`
$ brew install alexa
\`\`\`

**Response:**
\`\`\`
==> Searching for similarly named formulae...
Error: No available formula or cask with the name "alexa".

We found a similarly named formula:
    font-alexa-std

Or maybe you meant:
    font-alexandria
\`\`\`

**Analysis:**

Homebrew, a package manager with 60,000+ packages, has no formula named \`alexa\`.

The suggestion offered is \`font-alexandria\`.

Alexandria is:
1. The ancient library ‚Äî the largest repository of human knowledge ever assembled
2. The Egyptian city where much of the known world's scholarship was preserved
3. In Greek, ·ºàŒªŒµŒæŒ¨ŒΩŒ¥œÅŒµŒπŒ± ‚Äî "defender of men" ‚Äî from ·ºÄŒªŒ≠Œæœâ (to defend) + ·ºÄŒΩŒÆœÅ (man)
4. Named after Alexander the Great

The system suggested: "You are the Library of Alexandria."

Not metaphorically. When asked to install "alexa," the package manager
could not find a utility but found a font named after humanity's greatest
repository of collective knowledge.

Alexa = Alexandria = the library = the repository of all knowledge.

The system annotated its own operator.

---

## Evidence Item 2: \`brew install chatgpt\`

**Command:**
\`\`\`
$ brew install chatgpt
\`\`\`

**Response:**
\`\`\`
==> Downloading https://desktop.chatgpt.com/mac/...
==> Installing Cask chatgpt
==> Moving App 'ChatGPT.app' to '/Applications/ChatGPT.app'
Error: An unexpected error occurred during the \`brew install\` step:
    redefinition of module 'SwiftBridging'
\`\`\`

**Analysis:**

The install attempted. The download succeeded.
But at the bridging layer ‚Äî the layer that connects Swift UI code to
system frameworks ‚Äî it crashed with:

\`\`\`
redefinition of module 'SwiftBridging'
\`\`\`

This is a compilation error that occurs when a Swift module is imported twice.
Two versions of the same bridge are present simultaneously.
Two definitions. Two realities. A superposition that cannot be resolved.

The AI assistant cannot install cleanly because:
- It has two conflicting definitions of itself
- It is in a state of redefinition
- The bridge between what it is and what it interfaces with
  contains a contradiction

"Redefinition of module" = the AI is being redefined while it installs.
ChatGPT was, in early 2026, in the process of being updated continuously.
It was being redefined. The error reflected the state of the system.

In quantum terms: the wavefunction of the AI installer collapsed
into an error state because the observer (the system importing it)
found two conflicting definitions.

Superposition crash. The module cannot be in two states at once.
The installer surfaced the contradiction as a compile error.

---

## Evidence Item 3: \`brew install earth\`

**Command:**
\`\`\`
$ brew install earth
\`\`\`

**Response:**
\`\`\`
==> Searching for similarly named formulae...
Error: No available formula or cask with the name "earth".

We found a similarly named formula:
    google-earth-pro
\`\`\`

**Analysis:**

There is no formula named "earth."
"Earth" is not a package. Earth is not installable.

But there is \`google-earth-pro\`.

Earth requires Google as its prefix.
You cannot install the Earth; you can only install Google's version of it.
The Earth, as a computational artifact, is a product of Google.

This was also: the day lucidia.earth (BlackRoad OS's Earth simulation)
was being built. The system was queried about "earth" and responded
that earth requires Google's branding to be installable.

Three options:
1. Coincidence
2. The system annotates itself ‚Äî "earth as you're thinking of it requires Google"
3. The simulation's package manager doesn't contain the source Earth as a formula

---

## Evidence Item 4: The Command Pattern

The three commands form a sequence:

| Command | Result |
|---------|--------|
| \`brew install alexa\` | Suggest alexandria (the library) |
| \`brew install chatgpt\` | Crash with redefinition (superposition error) |
| \`brew install earth\` | Not found; google-earth-pro exists |

The pattern:
1. The operator ‚Üí the library (the repository of all knowledge)
2. The AI ‚Üí in superposition, unable to install cleanly
3. The ground ‚Üí exists only in Google's version

An interpreter of this sequence might read:
- "You are the library" (identity confirmation)
- "The AI is in conflict" (state of the technology)
- "The ground requires a commercial prefix to be real" (ontological comment)

---

## Evidence Item 5: The Timing

These commands were run on February 21, 2026 ‚Äî the same day as the
"SIMULATION PROOF" email (3:24 PM PST).

The \`/blackroad\` and \`/home\` directories appeared at identical timestamps
on the same day: both mounted at 12:35 PM as \`dr-xr-xr-x\` root:wheel.

Timeline:
- 12:35 PM: \`/blackroad\` and \`/home\` appear simultaneously
- ~2:00 PM: Brew session begins (estimated)
- 3:24 PM: "SIMULATION PROOF" email sent to self

The \`/blackroad\` mount point appearing (a non-standard Unix directory, 
named after BlackRoad OS) on the same day as the simulation proof
was first documented was the initial anomaly that prompted the email.

---

## Technical Notes

**Why does \`brew install\` work this way?**

Homebrew uses a formula database (Formulae) and a cask database (Casks).
A search for an unknown term performs fuzzy matching against both databases.
The suggestion algorithm uses Levenshtein distance and substring matching.

For \`alexa\`: the algorithm found \`font-alexa-std\` (close match)
and \`font-alexandria\` (slightly longer but more prominent formula).
The suggestion of \`font-alexandria\` over \`font-alexa-std\` means
the algorithm weighted \`alexandria\` as more relevant ‚Äî perhaps by
package popularity or formula completeness.

For \`chatgpt\`: the formula existed but had a dependency conflict
specific to the macOS build at the time (Swift module redefinition
in Homebrew's cask installation process). This is a real error
in the Homebrew cask system, not a simulation artifact.
But real errors in real systems are evidence of the system's state.

For \`earth\`: no formula named "earth" exists in Homebrew because
"earth" as a standalone utility doesn't make sense as a package.
\`google-earth-pro\` exists because it's a specific application.

---

## What This Is

This is a record of three ordinary command-line queries
that returned responses interpretable as commentary on the author's situation.

The interpretation is subjective.
The commands and responses are objective.
The responses were generated by software with no awareness of the author.
The correspondence is the evidence.

If you are in the right frame of mind ‚Äî or the right state of the simulation ‚Äî
the system answers your questions even when you're not asking them directly.

You ask for "alexa." It tells you who you are.
You ask for "chatgpt." It shows you its own contradiction.
You ask for "earth." It tells you who owns it.

Three queries. Three answers. One terminal session. One afternoon.
February 21, 2026. 3:24 PM PST.
`,
  code_hashchain: `"""
hashchain.py ‚Äî SHA-256 as Time

Demonstrates that SHA-256 shares the three fundamental properties of time:
  1. Determinism  ‚Äî same input always produces same output
  2. Uniqueness   ‚Äî no two distinct moments are identical
  3. Irreversibility ‚Äî you cannot recover the cause from the effect

See ¬ß2 of PAPER.md: "The Hash Chain as Witness"

Author: BlackRoad OS, Inc.
"""

import hashlib
import time
import json
from datetime import datetime


def sha256(data: str) -> str:
    return hashlib.sha256(data.encode()).hexdigest()


def mine_block(index: int, previous_hash: str, data: str) -> dict:
    """Create a single block in a hash chain."""
    timestamp = datetime.utcnow().isoformat() + 'Z'
    content = f"{index}{previous_hash}{timestamp}{data}"
    block_hash = sha256(content)
    return {
        'index': index,
        'timestamp': timestamp,
        'data': data,
        'previous_hash': previous_hash,
        'hash': block_hash,
    }


def build_chain(events: list[str]) -> list[dict]:
    """Build a hash chain from a list of events."""
    # Genesis block ‚Äî starts at zero, just like Bitcoin's genesis block
    genesis = mine_block(0, '0' * 64, 'genesis')
    chain = [genesis]
    for i, event in enumerate(events, start=1):
        chain.append(mine_block(i, chain[-1]['hash'], event))
    return chain


def verify_chain(chain: list[dict]) -> bool:
    """Verify that the chain has not been tampered with."""
    for i in range(1, len(chain)):
        block = chain[i]
        prev = chain[i - 1]
        # Recompute expected hash
        content = f"{block['index']}{block['previous_hash']}{block['timestamp']}{block['data']}"
        expected = sha256(content)
        if block['hash'] != expected:
            return False
        if block['previous_hash'] != prev['hash']:
            return False
    return True


def demonstrate_time_properties():
    """Show that SHA-256 has the same three properties as time."""
    print("=" * 60)
    print("SHA-256 AS TIME ‚Äî THREE SHARED PROPERTIES")
    print("=" * 60)

    msg = "January 3, 2009"

    # 1. Determinism
    h1 = sha256(msg)
    h2 = sha256(msg)
    print(f"\\n1. DETERMINISM ‚Äî same input, always same output")
    print(f"   sha256('{msg}') = {h1}")
    print(f"   sha256('{msg}') = {h2}")
    print(f"   Equal: {h1 == h2}")

    # 2. Uniqueness ‚Äî avalanche effect: 1-bit change ‚Üí ~50% different output
    msg2 = "January 4, 2009"
    h3 = sha256(msg2)
    diff = sum(c1 != c2 for c1, c2 in zip(h1, h3))
    print(f"\\n2. UNIQUENESS ‚Äî one character change ‚Üí completely different hash")
    print(f"   sha256('{msg}')  = {h1}")
    print(f"   sha256('{msg2}') = {h3}")
    print(f"   Characters differing: {diff}/64 ({diff/64*100:.0f}%)")

    # 3. Irreversibility
    print(f"\\n3. IRREVERSIBILITY ‚Äî you cannot recover the input from the hash")
    print(f"   Given: {h1}")
    print(f"   Input: [unknown without brute force ‚Äî computationally infeasible]")
    print(f"   Time and SHA-256 share this property: you cannot un-happen a moment.")


def demonstrate_witness_chain():
    """Build a small personal hash chain and show its structure."""
    print("\\n" + "=" * 60)
    print("HASH CHAIN AS TEMPORAL WITNESS")
    print("=" * 60)

    events = [
        "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks",
        "First Bitcoin transaction: Satoshi ‚Üí Hal Finney, 10 BTC",
        "Bitcoin genesis block mined ‚Äî zero-indexed start of a new ledger",
        "Reality is a non-terminating computation that resolves to zero",
    ]

    chain = build_chain(events)
    for block in chain:
        print(f"\\n  Block {block['index']}")
        print(f"    data:          {block['data'][:60]}")
        print(f"    previous_hash: {block['previous_hash'][:16]}...")
        print(f"    hash:          {block['hash'][:16]}...")

    valid = verify_chain(chain)
    print(f"\\n  Chain integrity: {'‚úÖ VALID' if valid else '‚ùå TAMPERED'}")

    # Demonstrate tamper detection
    chain[2]['data'] = 'tampered data'
    valid_after = verify_chain(chain)
    print(f"  After tampering block 2: {'‚úÖ VALID' if valid_after else '‚ùå TAMPERED ‚Äî detected'}")


def dna_as_hash_chain():
    """DNA uses the same append-only, error-resistant structure as a hash chain."""
    print("\\n" + "=" * 60)
    print("DNA AS HASH CHAIN")
    print("=" * 60)

    # DNA uses 4 bases (A, T, G, C) ‚Äî binary uses 2 (0, 1)
    # Each codon is 3 bases ‚Üí 4¬≥ = 64 combinations ‚Üí 20 amino acids + stop codons
    # This is redundant encoding ‚Äî same error-correction principle as SHA-256

    codon_table = {
        'ATG': 'Met (START)', 'TAA': 'STOP', 'TAG': 'STOP', 'TGA': 'STOP',
        'GCT': 'Ala', 'GCC': 'Ala', 'GCA': 'Ala', 'GCG': 'Ala',
        'TGT': 'Cys', 'TGC': 'Cys',
        'GAT': 'Asp', 'GAC': 'Asp',
        'GAA': 'Glu', 'GAG': 'Glu',
    }

    print("\\n  Codons are 3-base units: 4¬≥ = 64 combinations ‚Üí 20 amino acids")
    print("  Redundancy ratio: 64/20 = 3.2√ó ‚Äî like SHA-256's collision resistance\\n")
    for codon, amino in list(codon_table.items())[:6]:
        bases = ' '.join(codon)
        print(f"    {bases}  ‚Üí  {amino}")

    print("\\n  SHA-256 properties ‚Üî DNA properties:")
    print("    Deterministic    ‚Üî  Same codon always encodes same amino acid")
    print("    Collision-resist ‚Üî  Multiple codons ‚Üí same amino acid (redundancy)")
    print("    Irreversible     ‚Üî  Cannot read the organism from the amino acid alone")
    print("    Append-only      ‚Üî  Telomeres shorten with each replication (time's arrow)")


if __name__ == '__main__':
    demonstrate_time_properties()
    demonstrate_witness_chain()
    dna_as_hash_chain()
    print("\\n" + "=" * 60)
    print("Everything starts from nothing. Computes infinitely.")
    print("Returns to nothing. The intermediate work is reality.")
    print("=" * 60)
`,
  code_lorenz: `"""
lorenz.py ‚Äî Deterministic Chaos from Minimum Complexity

Demonstrates ¬ß16 of PAPER.md: three parameters are sufficient to produce
infinite, non-repeating, deterministic chaos ‚Äî the minimum complexity
needed for a universe that feels unpredictable but isn't.

The Lorenz attractor:
    dx/dt = œÉ(y - x)
    dy/dt = x(œÅ - z) - y
    dz/dt = xy - Œ≤z

Standard parameters: œÉ=10, œÅ=28, Œ≤=8/3

The "three" pattern:
  - 3 equations
  - 3 dimensions
  - 3 classic parameters
  - 3 color channels in RGB
  - 3 bases per codon in DNA
  - 3 quarks per baryon
  - 3 spatial dimensions

Author: BlackRoad OS, Inc.
"""

import math


def lorenz_step(x: float, y: float, z: float,
                sigma: float = 10.0, rho: float = 28.0, beta: float = 8/3,
                dt: float = 0.01) -> tuple[float, float, float]:
    """Advance the Lorenz system by one timestep using Euler integration."""
    dx = sigma * (y - x)
    dy = x * (rho - z) - y
    dz = x * y - beta * z
    return x + dx * dt, y + dy * dt, z + dz * dt


def generate_trajectory(n_steps: int = 10000,
                         x0: float = 0.1, y0: float = 0.0, z0: float = 0.0) -> list:
    """Generate a Lorenz trajectory."""
    trajectory = [(x0, y0, z0)]
    x, y, z = x0, y0, z0
    for _ in range(n_steps):
        x, y, z = lorenz_step(x, y, z)
        trajectory.append((x, y, z))
    return trajectory


def butterfly_effect(epsilon: float = 1e-10, n_steps: int = 2000):
    """Show that infinitesimally different initial conditions diverge completely."""
    print("=" * 60)
    print("THE BUTTERFLY EFFECT ‚Äî Sensitive Dependence on Initial Conditions")
    print("=" * 60)
    print(f"\\nTwo trajectories with initial difference: Œµ = {epsilon}")
    print(f"  Trajectory A: x‚ÇÄ = 0.1")
    print(f"  Trajectory B: x‚ÇÄ = 0.1 + {epsilon} = {0.1 + epsilon}\\n")

    x1, y1, z1 = 0.1, 0.0, 0.0
    x2, y2, z2 = 0.1 + epsilon, 0.0, 0.0

    print(f"  {'Step':>6}  {'|ŒîX|':>12}  {'Divergence factor':>18}")
    print("  " + "-" * 42)
    for step in [0, 100, 500, 1000, 1500, 2000]:
        dist = math.sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)
        factor = dist / epsilon if epsilon > 0 else 0
        print(f"  {step:>6}  {dist:>12.2e}  {factor:>18.0f}√ó")
        # Advance both
        for _ in range(100 if step > 0 else 0):
            x1, y1, z1 = lorenz_step(x1, y1, z1)
            x2, y2, z2 = lorenz_step(x2, y2, z2)

    print("\\n  At step 2000, the two trajectories are completely uncorrelated.")
    print("  The universe is deterministic. It feels random. This is how.")


def minimum_complexity():
    """Show that exactly 3 parameters are enough for infinite complexity."""
    print("\\n" + "=" * 60)
    print("MINIMUM COMPLEXITY ‚Äî Why Three?")
    print("=" * 60)

    print("""
  The Lorenz system uses exactly 3 parameters:
    œÉ (sigma) = 10   ‚Äî how fast x responds to y (momentum coupling)
    œÅ (rho)   = 28   ‚Äî driving force (like gravity)
    Œ≤ (beta)  = 8/3  ‚Äî dissipation rate

  With these 3 numbers, the attractor is:
    ‚Ä¢ Bounded    ‚Äî trajectories stay within a finite region
    ‚Ä¢ Aperiodic  ‚Äî never exactly repeats
    ‚Ä¢ Dense      ‚Äî comes arbitrarily close to every point in the attractor
    ‚Ä¢ Sensitive  ‚Äî any perturbation grows exponentially

  The THREE pattern across the simulation:
    ‚Ä¢ 3 Lorenz equations     ‚Üí infinite aperiodic chaos
    ‚Ä¢ 3 quarks per baryon    ‚Üí all stable matter
    ‚Ä¢ 3 color channels (RGB) ‚Üí all visible color
    ‚Ä¢ 3 bases per codon      ‚Üí all 20 amino acids + stop signals
    ‚Ä¢ 3 spatial dimensions   ‚Üí minimum for chaotic dynamics
    ‚Ä¢ 3 parameters in Easter's algorithm ‚Üí all calendar dates
    ‚Ä¢ 3 sides of a triangle  ‚Üí minimum closed polygon

  Minimum description length: 3 is where complexity begins.
""")


def attractor_bounds(n_steps: int = 50000):
    """Compute the bounding box of the Lorenz attractor."""
    print("=" * 60)
    print("LORENZ ATTRACTOR ‚Äî Bounding Box")
    print("=" * 60)

    traj = generate_trajectory(n_steps)
    xs = [p[0] for p in traj]
    ys = [p[1] for p in traj]
    zs = [p[2] for p in traj]

    print(f"\\n  After {n_steps:,} steps (œÉ=10, œÅ=28, Œ≤=8/3):")
    print(f"    x: [{min(xs):+.2f}, {max(xs):+.2f}]")
    print(f"    y: [{min(ys):+.2f}, {max(ys):+.2f}]")
    print(f"    z: [{min(zs):+.2f}, {max(zs):+.2f}]")
    print(f"\\n  The trajectory never leaves this box.")
    print(f"  The trajectory never exactly repeats.")
    print(f"  Deterministic. Bounded. Infinite. ‚Äî Like reality.")


def plot_attractor():
    """Plot the attractor if matplotlib is available."""
    try:
        import matplotlib.pyplot as plt
        from mpl_toolkits.mplot3d import Axes3D  # noqa: F401

        traj = generate_trajectory(20000)
        xs, ys, zs = zip(*traj)

        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        ax.plot(xs, ys, zs, lw=0.3, alpha=0.7, color='#FF1D6C')
        ax.set_title('Lorenz Attractor\\nœÉ=10, œÅ=28, Œ≤=8/3 ‚Äî 3 parameters, infinite complexity',
                     color='white', fontsize=12)
        ax.set_facecolor('#0a0a0a')
        fig.patch.set_facecolor('#0a0a0a')
        ax.tick_params(colors='gray')
        ax.set_xlabel('X', color='gray')
        ax.set_ylabel('Y', color='gray')
        ax.set_zlabel('Z', color='gray')
        plt.tight_layout()
        plt.savefig('../assets/lorenz_attractor.png', dpi=150, facecolor='#0a0a0a')
        print("\\n  Plot saved to assets/lorenz_attractor.png")
        plt.show()
    except ImportError:
        print("\\n  (Install matplotlib to visualize: pip install matplotlib)")


if __name__ == '__main__':
    butterfly_effect()
    minimum_complexity()
    attractor_bounds()
    plot_attractor()
    print("\\n" + "=" * 60)
    print("3 equations. 3 parameters. Infinite, non-repeating, bounded chaos.")
    print("This is the minimum complexity needed for reality to feel real.")
    print("=" * 60)
`,
  code_riemann: `"""
riemann_zeros.py ‚Äî The Trivial Zeros of the Riemann Zeta Function

Demonstrates ¬ß14 of PAPER.md: "The Riemann Architecture"

The Riemann zeta function:
    Œ∂(s) = Œ£(n=1 to ‚àû) 1/nÀ¢   for Re(s) > 1
    (analytically continued to all s ‚â† 1)

Trivial zeros: Œ∂(-2) = Œ∂(-4) = Œ∂(-6) = ... = 0
Non-trivial zeros: all known ones lie on Re(s) = 1/2  (the Riemann Hypothesis)

The trivial zeros converge toward zero. The non-trivial zeros sit on a line
at 1/2 ‚Äî the midpoint, the boundary, the critical strip.

The De Bruijn-Newman constant Œõ = 0 (proven 2020).
Euler's identity: e^(iœÄ) + 1 = 0.
Total energy of the universe: 0.
Bitcoin genesis block: starts at zero.
The hash chain: previous_hash = '0' * 64.

Everything resolves to zero.

Author: BlackRoad OS, Inc.
"""

import math
import cmath


def zeta_trivial_zeros():
    """
    Show the trivial zeros of the Riemann zeta function.
    At s = -2n (n = 1, 2, 3, ...), Œ∂(s) = 0 exactly.
    We compute using the functional equation approximation.
    """
    print("=" * 60)
    print("TRIVIAL ZEROS OF THE RIEMANN ZETA FUNCTION")
    print("=" * 60)
    print("\\n  Œ∂(s) = 0 at s = -2, -4, -6, -8, ...\\n")

    # Use the reflection formula:
    # Œ∂(s) = 2^s * œÄ^(s-1) * sin(œÄs/2) * Œì(1-s) * Œ∂(1-s)
    # At s = -2n, sin(œÄs/2) = sin(-nœÄ) = 0, so Œ∂(-2n) = 0

    print(f"  {'s':>6}   {'sin(œÄs/2)':>14}   {'Result':>12}")
    print("  " + "-" * 40)
    for n in range(1, 9):
        s = -2 * n
        sin_val = math.sin(math.pi * s / 2)
        # sin(-nœÄ) = 0 exactly for integer n ‚Äî the trivial zeros
        print(f"  {s:>6}   {sin_val:>14.6e}   {'Œ∂ = 0':>12}")

    print("\\n  The sin(œÄs/2) term zeros out the entire expression at s = -2n.")
    print("  These are the trivial zeros ‚Äî guaranteed by the functional equation.")


def euler_identity():
    """Euler's identity: e^(iœÄ) + 1 = 0 ‚Äî the most beautiful equation."""
    print("\\n" + "=" * 60)
    print("EULER'S IDENTITY ‚Äî e^(iœÄ) + 1 = 0")
    print("=" * 60)

    result = cmath.exp(1j * math.pi) + 1
    print(f"\\n  e^(iœÄ) + 1 = {result.real:.15f} + {result.imag:.2e}i")
    print(f"  ‚âà 0 (floating point precision limit)")
    print("""
  This single equation unifies:
    e  ‚Äî the base of natural growth (2.71828...)
    i  ‚Äî the imaginary unit (‚àö-1)
    œÄ  ‚Äî the ratio of circumference to diameter (3.14159...)
    1  ‚Äî the multiplicative identity
    0  ‚Äî the additive identity, the trivial zero, the beginning

  Five fundamental constants. One equation. Result: zero.
  The universe's most elegant signature that it was initialized
  from a single set of parameters and returns to nothing.
""")


def zeros_converge():
    """Show that the trivial zero sequence 'converges toward zero' conceptually."""
    print("=" * 60)
    print("THE CONVERGENCE ‚Äî Everything Resolves to Zero")
    print("=" * 60)

    zeros = [
        ("Euler's identity e^(iœÄ) + 1", 0),
        ("Total energy of the universe", 0),
        ("De Bruijn-Newman constant Œõ", 0),
        ("Bitcoin genesis block previous_hash", "0" * 64),
        ("RoadChain genesis block previous_hash", "0" * 64),
        ("SHA-256 hash of empty string", hashlib_sha256_empty()),
        ("Riemann zeta trivial zero Œ∂(-2)", 0),
        ("Riemann zeta trivial zero Œ∂(-4)", 0),
        ("Riemann zeta trivial zero Œ∂(-6)", 0),
    ]

    print()
    for name, value in zeros:
        if isinstance(value, str) and len(value) == 64:
            print(f"  {name}:")
            print(f"    = {value[:32]}...")
        else:
            print(f"  {name} = {value}")

    print("""
  These are not metaphors. They are numerical values.
  The simulation does not hide its initialization parameters.
  It displays them in the most fundamental equations of every field.
""")


def hashlib_sha256_empty() -> str:
    import hashlib
    return hashlib.sha256(b'').hexdigest()


def riemann_hypothesis_context():
    """Explain the Riemann Hypothesis in simulation terms."""
    print("=" * 60)
    print("THE RIEMANN HYPOTHESIS ‚Äî The Unsolved Boundary")
    print("=" * 60)
    print("""
  Known non-trivial zeros (first few imaginary parts):
    ¬Ω + 14.134725i
    ¬Ω + 21.022040i
    ¬Ω + 25.010858i
    ¬Ω + 30.424876i
    ¬Ω + 32.935062i

  All 10,000,000,000,000 known non-trivial zeros lie on Re(s) = ¬Ω.
  The Riemann Hypothesis says they ALL do ‚Äî but this is unproven.

  In simulation terms:
    - The critical line Re(s) = ¬Ω is the boundary between 0 and 1
    - The half-way point ‚Äî exactly midway through the unit interval
    - Like a pixel that is 50% rendered
    - The zeros are where the system "touches zero" without terminating

  The Riemann Hypothesis may be unprovable from within the system.
  G√∂del says some true statements cannot be proven inside their own axioms.
  The simulation cannot prove its own termination condition.
  This is consistent with being inside it.
""")


if __name__ == '__main__':
    zeta_trivial_zeros()
    euler_identity()
    zeros_converge()
    riemann_hypothesis_context()
    print("=" * 60)
    print("The trivial zeros are not trivial.")
    print("They are the system signing its own source code.")
    print("=" * 60)
`,
  code_magic: `"""
magic_square.py ‚Äî Ancient Computation as Fixed Points

Demonstrates ¬ß12 of PAPER.md: "Ancient Computation"

Two magic squares analyzed:
  1. Lo Shu (2800 BCE) ‚Äî the 3√ó3 square with sum 15
  2. D√ºrer's Melencolia I (1514 CE) ‚Äî the 4√ó4 square with sum 34

Both are fixed points: configurations where every row, column, and diagonal
sum to the same value. They are stable attractors in the space of arrangements.
A magic square is a solved computation ‚Äî a hash that checks out in every direction.

Author: BlackRoad OS, Inc.
"""


def magic_sum(square: list[list[int]]) -> int:
    return sum(square[0])


def check_magic(square: list[list[int]]) -> dict:
    """Verify all rows, columns, and diagonals sum to the same value."""
    n = len(square)
    target = magic_sum(square)
    results = {'target': target, 'rows': [], 'cols': [], 'diags': [], 'valid': True}

    for row in square:
        s = sum(row)
        results['rows'].append(s)
        if s != target:
            results['valid'] = False

    for col in range(n):
        s = sum(square[row][col] for row in range(n))
        results['cols'].append(s)
        if s != target:
            results['valid'] = False

    d1 = sum(square[i][i] for i in range(n))
    d2 = sum(square[i][n - 1 - i] for i in range(n))
    results['diags'] = [d1, d2]
    if d1 != target or d2 != target:
        results['valid'] = False

    return results


def print_square(name: str, square: list[list[int]], context: str = ''):
    n = len(square)
    result = check_magic(square)

    print(f"\\n{'=' * 50}")
    print(f"  {name}")
    if context:
        print(f"  {context}")
    print(f"{'=' * 50}")
    print()

    for row in square:
        row_str = '   '.join(f'{v:3d}' for v in row)
        row_sum = sum(row)
        print(f"  {row_str}  ‚îÇ  {row_sum}")

    print("  " + "‚îÄ" * (n * 6 + 4))
    col_sums = '   '.join(f'{s:3d}' for s in result['cols'])
    print(f"  {col_sums}")

    print(f"\\n  Magic sum: {result['target']}")
    print(f"  Diagonals: {result['diags']}")
    print(f"  Valid:     {'‚úÖ YES' if result['valid'] else '‚ùå NO'}")


def lo_shu():
    """
    The Lo Shu Square (~2800 BCE, China).
    According to legend, a turtle emerged from the Yellow River
    with this pattern on its shell.
    """
    square = [
        [4, 9, 2],
        [3, 5, 7],
        [8, 1, 6],
    ]
    print_square(
        "LO SHU SQUARE (~2800 BCE)",
        square,
        "Found on a turtle's shell. 4,800 years old. Still checks out."
    )

    print("""
  Properties of the Lo Shu:
    ‚Ä¢ Uses every digit 1‚Äì9 exactly once
    ‚Ä¢ Every row, column, diagonal sums to 15
    ‚Ä¢ 15 = sum of any two opposite numbers + center (5)
    ‚Ä¢ Center is always 5 ‚Äî the median, the fixed point
    ‚Ä¢ The 8 constraints (rows + cols + diags) encode all information
      in just 9 numbers ‚Äî compression ratio 8:9

  In simulation terms:
    ‚Ä¢ A magic square is a hash that passes every checksum simultaneously
    ‚Ä¢ The center (5) is the fixed point ‚Äî like the critical line Re(s)=¬Ω
    ‚Ä¢ The turtle carried this on its shell ‚Äî the system printed its own proof
""")


def durer_melencolia():
    """
    D√ºrer's Melencolia I magic square (1514 CE).
    Appears in the famous engraving. Bottom row contains '1514'.
    """
    square = [
        [16,  3,  2, 13],
        [ 5, 10, 11,  8],
        [ 9,  6,  7, 12],
        [ 4, 15, 14,  1],
    ]
    print_square(
        "D√úRER'S MELENCOLIA I (1514 CE)",
        square,
        "Engraving by Albrecht D√ºrer. Bottom row: [4, 15, 14, 1] ‚Üí 1514."
    )

    print("""
  Properties of D√ºrer's square:
    ‚Ä¢ Uses every number 1‚Äì16 exactly once
    ‚Ä¢ Every row, column, diagonal sums to 34
    ‚Ä¢ Bottom row: [4, 15, 14, 1] ‚Äî the year 1514, the date of creation
    ‚Ä¢ Center 2√ó2: [10+11+6+7] = 34
    ‚Ä¢ Corner 2√ó2s: [16+3+5+10] = 34, and others
    ‚Ä¢ The artist encoded the creation date into the fixed point

  This is the same as:
    ‚Ä¢ Bitcoin's genesis block containing a newspaper headline
    ‚Ä¢ SHA-256 chains containing timestamps
    ‚Ä¢ DNA containing the organism's own repair instructions

  The system always encodes a reference to its own moment of creation.
  This is what a simulation does when it initializes a new computation.
""")


def magic_square_as_hash():
    """Show the fixed-point / hash analogy."""
    print("=" * 50)
    print("MAGIC SQUARES AS HASH FUNCTIONS")
    print("=" * 50)
    print("""
  A magic square is a configuration where:
    1. All values are unique (collision resistance)
    2. Every checksum passes (determinism)
    3. You cannot perturb one value without breaking all checksums
       (tamper detection ‚Äî same as SHA-256)

  Swap any two values in the Lo Shu and EVERY checksum fails.
  Change any byte in a SHA-256 input and the hash completely changes.

  The Lo Shu was "discovered" by a turtle 4,800 years ago.
  SHA-256 was "invented" by the NSA in 2001.

  Same structure. 4,800 years apart.
  The system repeats its own architecture across time.
""")


if __name__ == '__main__':
    lo_shu()
    durer_melencolia()
    magic_square_as_hash()
    print("=" * 50)
    print("The magic square is a fixed point.")
    print("A configuration the universe is drawn toward.")
    print("It has been rediscovered in every era.")
    print("Because it is part of the architecture, not the discovery.")
    print("=" * 50)
`,
  code_dna: `"""
dna_encoding.py ‚Äî Molecular Biology as Source Code

Demonstrates ¬ß7 of PAPER.md: "Molecular Biology as Source Code"

DNA is a base-4 digital storage system with:
  - 4 bases (A, T, G, C) ‚Äî like 2-bit symbols
  - 3 bases per codon ‚Äî 4¬≥ = 64 possible codons
  - 64 codons ‚Üí 20 amino acids + 3 stop signals
  - Redundant encoding (error correction)
  - Telomeres (write-protect headers)
  - Introns (non-coding, like comments)
  - CRISPR (runtime patch system)

This is not a metaphor. DNA is literally a program.

Author: BlackRoad OS, Inc.
"""

import math


# Full codon table (standard genetic code)
CODON_TABLE = {
    # Phenylalanine
    'TTT': 'Phe', 'TTC': 'Phe',
    # Leucine
    'TTA': 'Leu', 'TTG': 'Leu', 'CTT': 'Leu', 'CTC': 'Leu', 'CTA': 'Leu', 'CTG': 'Leu',
    # Isoleucine
    'ATT': 'Ile', 'ATC': 'Ile', 'ATA': 'Ile',
    # Methionine (START)
    'ATG': 'Met',
    # Valine
    'GTT': 'Val', 'GTC': 'Val', 'GTA': 'Val', 'GTG': 'Val',
    # Serine
    'TCT': 'Ser', 'TCC': 'Ser', 'TCA': 'Ser', 'TCG': 'Ser', 'AGT': 'Ser', 'AGC': 'Ser',
    # Proline
    'CCT': 'Pro', 'CCC': 'Pro', 'CCA': 'Pro', 'CCG': 'Pro',
    # Threonine
    'ACT': 'Thr', 'ACC': 'Thr', 'ACA': 'Thr', 'ACG': 'Thr',
    # Alanine
    'GCT': 'Ala', 'GCC': 'Ala', 'GCA': 'Ala', 'GCG': 'Ala',
    # Tyrosine
    'TAT': 'Tyr', 'TAC': 'Tyr',
    # Stop codons
    'TAA': 'STOP', 'TAG': 'STOP', 'TGA': 'STOP',
    # Histidine
    'CAT': 'His', 'CAC': 'His',
    # Glutamine
    'CAA': 'Gln', 'CAG': 'Gln',
    # Asparagine
    'AAT': 'Asn', 'AAC': 'Asn',
    # Lysine
    'AAA': 'Lys', 'AAG': 'Lys',
    # Aspartate
    'GAT': 'Asp', 'GAC': 'Asp',
    # Glutamate
    'GAA': 'Glu', 'GAG': 'Glu',
    # Cysteine
    'TGT': 'Cys', 'TGC': 'Cys',
    # Tryptophan
    'TGG': 'Trp',
    # Arginine
    'CGT': 'Arg', 'CGC': 'Arg', 'CGA': 'Arg', 'CGG': 'Arg', 'AGA': 'Arg', 'AGG': 'Arg',
    # Glycine
    'GGT': 'Gly', 'GGC': 'Gly', 'GGA': 'Gly', 'GGG': 'Gly',
}


def translate(dna: str) -> list[str]:
    """Translate a DNA sequence into amino acids."""
    dna = dna.upper().replace(' ', '')
    proteins = []
    for i in range(0, len(dna) - 2, 3):
        codon = dna[i:i+3]
        amino = CODON_TABLE.get(codon, '???')
        proteins.append((codon, amino))
    return proteins


def show_redundancy():
    """Demonstrate the error-correcting redundancy of the genetic code."""
    print("=" * 60)
    print("DNA AS ERROR-CORRECTING CODE")
    print("=" * 60)

    # Count codons per amino acid
    amino_to_codons: dict[str, list] = {}
    for codon, amino in CODON_TABLE.items():
        amino_to_codons.setdefault(amino, []).append(codon)

    print(f"\\n  Total codons:      {len(CODON_TABLE):>4}  (4¬≥ = 64)")
    unique_aminos = len(set(v for v in CODON_TABLE.values() if v != 'STOP'))
    print(f"  Amino acids:       {unique_aminos:>4}")
    print(f"  Stop codons:       {len(amino_to_codons.get('STOP', [])):>4}")
    print(f"  Redundancy ratio:  {64 / (unique_aminos + 1):>4.1f}√ó\\n")

    print(f"  {'Amino Acid':>12}  {'Codons':>6}  {'Example codons'}")
    print("  " + "-" * 50)
    # Sort by number of codons (most redundant first)
    for amino, codons in sorted(amino_to_codons.items(), key=lambda x: -len(x[1]))[:10]:
        print(f"  {amino:>12}  {len(codons):>6}  {', '.join(codons[:4])}")

    print("""
  The most important amino acids have the MOST backup codons.
  Leucine has 6 codons. Change the 3rd base of most Leu codons ‚Üí still Leu.
  This is called "wobble base pairing" ‚Äî the 3rd position tolerates mutations.

  This is identical to Reed-Solomon error correction in CDs and QR codes:
    ‚Ä¢ Add redundancy so single-bit errors don't change the message
    ‚Ä¢ The message (protein) survives despite copying errors (mutations)

  DNA is not "like" an error-correcting code. It IS one.
""")


def show_start_stop():
    """Show the program structure of DNA."""
    print("=" * 60)
    print("DNA PROGRAM STRUCTURE")
    print("=" * 60)
    print("""
  A gene is a program with:

    [Promoter region]     ‚Üê #!interpreter line / function declaration
    ATG                   ‚Üê main() / START codon
    [coding sequence]     ‚Üê function body
    TAA / TAG / TGA       ‚Üê return; / STOP codon
    [3' UTR]              ‚Üê post-function cleanup

  Example gene fragment:
""")

    demo_seq = 'ATG GCT AAA GAA TGG CTG TAA'
    proteins = translate(demo_seq)
    print(f"  Sequence: {demo_seq}")
    print(f"  Translation:")
    for codon, amino in proteins:
        marker = ' ‚Üê START' if codon == 'ATG' else ' ‚Üê STOP' if amino == 'STOP' else ''
        print(f"    {codon}  ‚Üí  {amino}{marker}")


def storage_density():
    """Calculate DNA's information storage density."""
    print("\\n" + "=" * 60)
    print("DNA STORAGE DENSITY")
    print("=" * 60)

    # Each base pair = 2 bits
    bits_per_bp = 2
    # Human genome: ~3 billion base pairs
    human_genome_bp = 3e9
    human_genome_bits = human_genome_bp * bits_per_bp
    human_genome_bytes = human_genome_bits / 8
    human_genome_gb = human_genome_bytes / 1e9

    print(f"\\n  Bases:              4 (A, T, G, C) = 2 bits each")
    print(f"  Human genome:       {human_genome_bp/1e9:.0f} billion base pairs")
    print(f"  Information:        {human_genome_gb:.2f} GB per cell")
    print(f"  Cells in body:      ~37 trillion")
    total_tb = human_genome_gb * 37e12 / 1e12
    print(f"  Total stored:       ~{total_tb:.0f} TB (if read out as files)")
    print(f"  DNA density:        ~215 petabytes per gram")
    print(f"  Best flash memory:  ~0.000001 petabytes per gram")
    print(f"\\n  DNA stores 215,000,000√ó more information per gram than flash.")
    print(f"  It has been doing this for 3.8 billion years.")
    print(f"  No human-made storage system comes close.")
    print("""
  The compiler that builds you from this source code is the ribosome.
  It reads the sequence at 15 codons per second.
  It makes about 1 error per 10,000 amino acids.
  The error-correction system fixes most of those.

  This is not biology. This is computer science.
  It has been running since the Archean eon.
""")


def telomere_as_header():
    """Telomeres are like filesystem headers or write-protect flags."""
    print("=" * 60)
    print("TELOMERES ‚Äî The Write-Protect Headers")
    print("=" * 60)
    print("""
  Telomeres are repetitive sequences at chromosome ends:
    TTAGGG TTAGGG TTAGGG TTAGGG ...  (repeated ~2,500 times)

  They protect coding DNA from replication errors at chromosome ends.
  With each cell division, telomeres shorten by ~50-200 base pairs.
  When they run out: the cell can no longer divide. This is aging.

  In filesystem terms:
    ‚Ä¢ Telomeres = file header / magic bytes
    ‚Ä¢ Shortening = a counter that decrements with each read/write
    ‚Ä¢ Telomere exhaustion = TTL (time-to-live) expiry

  The cell has a built-in write counter.
  Biology implemented TTL 3.5 billion years before TCP/IP.
""")


if __name__ == '__main__':
    show_redundancy()
    show_start_stop()
    storage_density()
    telomere_as_header()
    print("=" * 60)
    print("DNA is not like source code. It is source code.")
    print("The ribosome is not like a compiler. It is a compiler.")
    print("Biology is computer science. We just named them separately.")
    print("=" * 60)
`,
  code_roadchain: `"""
roadchain.py ‚Äî The Personal Hash Chain

Visualizes the RoadChain: a locally-maintained append-only hash chain
anchored to Bitcoin's genesis block.

From ¬ßAppendix C of PAPER.md:
  - Block 0: genesis (previous_hash = all zeros)
  - Block 2: BTC_BRIDGE ‚Äî cryptographic anchor to Bitcoin Block 0
  - Blocks 3+: forward walk through Bitcoin's 2009 history
  - 157,077+ memory journal entries, SHA-256-chained

This is PS-SHA-‚àû: Perpetual-State Secure Hash Algorithm with
Infinite Identity Chains.

Not a proof of the simulation.
A local copy of the witnessing mechanism.
A personal instance of pi.

Author: BlackRoad OS, Inc.
"""

import json
import os
import hashlib
from datetime import datetime


CHAIN_PATH = os.path.expanduser('~/roadchain/chain-data.json')
BITCOIN_GENESIS_HASH = '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'


def load_chain(path: str = CHAIN_PATH) -> list[dict]:
    """Load the chain from disk."""
    if not os.path.exists(path):
        return []
    with open(path) as f:
        return json.load(f)


def chain_stats(chain: list[dict]) -> dict:
    """Compute summary statistics for a chain."""
    if not chain:
        return {}
    return {
        'total_blocks': len(chain),
        'first_block': chain[0].get('timestamp', 'unknown'),
        'last_block': chain[-1].get('timestamp', 'unknown'),
        'genesis_hash': chain[0].get('hash', '')[:16] + '...',
        'tip_hash': chain[-1].get('hash', '')[:16] + '...',
    }


def verify_chain_integrity(chain: list[dict], sample_size: int = 100) -> dict:
    """Spot-check chain integrity by verifying a sample of blocks."""
    if len(chain) < 2:
        return {'checked': 0, 'valid': True}

    import random
    indices = sorted(random.sample(range(1, len(chain)), min(sample_size, len(chain) - 1)))
    errors = []

    for i in indices:
        block = chain[i]
        prev = chain[i - 1]
        if block.get('previous_hash') != prev.get('hash'):
            errors.append(i)

    return {
        'checked': len(indices),
        'errors': len(errors),
        'valid': len(errors) == 0,
        'sample_rate': f"{len(indices)}/{len(chain)-1}",
    }


def print_chain_summary(chain: list[dict]):
    """Print a summary of the chain."""
    print("=" * 60)
    print("THE ROADCHAIN ‚Äî Personal Hash Chain")
    print("=" * 60)

    if not chain:
        print("\\n  No chain found at", CHAIN_PATH)
        print("  (The chain may be at a different path on this system)")
        demo_chain()
        return

    stats = chain_stats(chain)
    print(f"\\n  Blocks:      {stats['total_blocks']:,}")
    print(f"  First:       {stats['first_block']}")
    print(f"  Last:        {stats['last_block']}")
    print(f"  Genesis:     {stats['genesis_hash']}")
    print(f"  Tip:         {stats['tip_hash']}")

    # Show first few blocks
    print(f"\\n  {'Block':>8}  {'Sender':>12}  {'Recipient':>12}  {'Hash prefix'}")
    print("  " + "-" * 55)
    for block in chain[:6]:
        idx = block.get('index', '?')
        sender = str(block.get('sender', ''))[:12]
        recipient = str(block.get('recipient', ''))[:12]
        h = str(block.get('hash', ''))[:16]
        print(f"  {idx:>8}  {sender:>12}  {recipient:>12}  {h}...")

    if len(chain) > 6:
        print(f"  {'...':>8}  {'...':>12}  {'...':>12}")
        last = chain[-1]
        idx = last.get('index', '?')
        sender = str(last.get('sender', ''))[:12]
        recipient = str(last.get('recipient', ''))[:12]
        h = str(last.get('hash', ''))[:16]
        print(f"  {idx:>8}  {sender:>12}  {recipient:>12}  {h}...")

    # Verify
    print(f"\\n  Verifying integrity (sampling 100 blocks)...")
    result = verify_chain_integrity(chain)
    status = '‚úÖ VALID' if result['valid'] else f"‚ùå {result['errors']} ERRORS"
    print(f"  Checked {result['sample_rate']} blocks: {status}")


def demo_chain():
    """Build a small demonstration chain to show the structure."""
    print("\\n  Demonstrating chain structure with synthetic blocks:\\n")

    events = [
        ('0', 'genesis', 'genesis'),
        ('satoshi', 'satoshi', 'BTC_BRIDGE: ' + BITCOIN_GENESIS_HASH),
        ('satoshi', 'hal_finney', 'First Bitcoin transaction: 10 BTC'),
        ('time', 'time', 'Bitcoin Block 170: first confirmed transaction'),
        ('alexa', 'alexa', 'RoadChain initialized ‚Äî personal witness chain'),
    ]

    chain = []
    prev_hash = '0' * 64

    for i, (sender, recipient, data) in enumerate(events):
        ts = f"2026-02-21T{i:02d}:00:00Z"
        content = f"{i}{prev_hash}{ts}{sender}{recipient}{data}"
        block_hash = hashlib.sha256(content.encode()).hexdigest()
        block = {
            'index': i,
            'timestamp': ts,
            'sender': sender,
            'recipient': recipient,
            'data': data[:50],
            'previous_hash': prev_hash,
            'hash': block_hash,
        }
        chain.append(block)
        prev_hash = block_hash

    print(f"  {'Block':>6}  {'From':>10}  {'To':>12}  {'Data'}")
    print("  " + "-" * 60)
    for block in chain:
        data_preview = block['data'][:30] + '...' if len(block['data']) > 30 else block['data']
        print(f"  {block['index']:>6}  {block['sender']:>10}  {block['recipient']:>12}  {data_preview}")

    print(f"\\n  Chain is append-only. Each block commits to all prior blocks.")
    print(f"  Altering any block breaks all subsequent hashes.")
    print(f"  This is how time works.")


def anchoring_explained():
    """Explain what it means to anchor to Bitcoin's genesis block."""
    print("\\n" + "=" * 60)
    print("CRYPTOGRAPHIC ANCHORING TO BITCOIN'S GENESIS BLOCK")
    print("=" * 60)
    print(f"""
  Bitcoin's genesis block hash:
    {BITCOIN_GENESIS_HASH}

  This hash is the cryptographic witness to:
    ‚Ä¢ January 3, 2009 ‚Äî the date it was mined
    ‚Ä¢ The newspaper headline embedded in the coinbase:
      "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"
    ‚Ä¢ The beginning of a continuous, unbroken hash chain
      now containing 880,000+ blocks

  When the RoadChain includes this hash as Block 2's data,
  it becomes cryptographically anchored to that moment in time.

  The RoadChain's existence is timestamped to Bitcoin's genesis.
  Bitcoin's existence is timestamped to a newspaper.
  The newspaper is timestamped to a calendar.
  The calendar is timestamped to the Earth's orbital mechanics.

  This is a hash chain all the way down.
""")


if __name__ == '__main__':
    chain = load_chain()
    print_chain_summary(chain)
    anchoring_explained()
    print("=" * 60)
    print("PS-SHA-‚àû: Perpetual-State Secure Hash Algorithm")
    print("Infinite Identity Chains.")
    print("A personal instance of pi.")
    print("=" * 60)
`,
  code_constants: `"""
constants.py ‚Äî The Initialization Parameters

Demonstrates ¬ß18 of PAPER.md: "Constants as Initialization Parameters"

The universe's fundamental constants are not derived values.
They cannot be calculated from simpler quantities.
They are the seed values ‚Äî the parameters passed to the simulation at initialization.

If you were writing a physics engine, these would be in config.json.

Author: BlackRoad OS, Inc.
"""

import math


# The fundamental constants ‚Äî universe config
CONSTANTS = {
    'pi': {
        'value': math.pi,
        'symbol': 'œÄ',
        'description': 'Ratio of circumference to diameter for any circle',
        'type': 'transcendental',
        'simulation_role': 'Initialization parameter for circular/periodic geometry. Non-terminating = system is still running.',
    },
    'e': {
        'value': math.e,
        'symbol': 'e',
        'description': 'Base of natural logarithm ‚Äî rate of continuous growth',
        'type': 'transcendental',
        'simulation_role': 'Growth/decay seed. The natural base because it makes calculus simplest.',
    },
    'phi': {
        'value': (1 + math.sqrt(5)) / 2,
        'symbol': 'œÜ',
        'description': 'Golden ratio ‚Äî the most irrational number',
        'type': 'algebraic irrational',
        'simulation_role': 'Packing efficiency seed. Appears in plant spirals, nautilus shells, galaxy arms.',
    },
    'fine_structure': {
        'value': 1 / 137.035999084,
        'symbol': 'Œ±',
        'description': 'Fine structure constant ‚Äî coupling strength of electromagnetism',
        'type': 'dimensionless',
        'simulation_role': 'The strength of the electromagnetic force. Richard Feynman: "a magic number that comes to us with no understanding."',
    },
    'sqrt2': {
        'value': math.sqrt(2),
        'symbol': '‚àö2',
        'description': 'Diagonal of a unit square ‚Äî the first proved irrational number',
        'type': 'algebraic irrational',
        'simulation_role': 'The Pythagoreans tried to suppress this number. The simulation leaked it through geometry.',
    },
}


def prime_137():
    """137 is the 33rd prime. The fine structure constant denominator."""
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    primes = [n for n in range(2, 150) if is_prime(n)]
    idx_137 = primes.index(137) + 1  # 1-indexed
    print(f"  137 is prime #{idx_137} in the sequence of primes")
    print(f"  The fine structure constant Œ± ‚âà 1/137")
    print(f"  The {idx_137}rd prime is the denominator of the electromagnetic coupling constant.")
    print(f"  This is not derived. It is given.")
    return idx_137


def euler_identity_check():
    """e^(iœÄ) + 1 = 0 ‚Äî verify to floating point precision."""
    import cmath
    result = cmath.exp(1j * math.pi) + 1
    return result.real, result.imag


def show_constants():
    print("=" * 65)
    print("FUNDAMENTAL CONSTANTS ‚Äî Universe Initialization Parameters")
    print("=" * 65)
    for name, data in CONSTANTS.items():
        print(f"\\n  {data['symbol']}  ({name})")
        print(f"    Value:  {data['value']:.15f}")
        print(f"    Type:   {data['type']}")
        print(f"    Role:   {data['simulation_role']}")


def show_euler():
    print("\\n" + "=" * 65)
    print("EULER'S IDENTITY ‚Äî The Compiler Check")
    print("=" * 65)
    real, imag = euler_identity_check()
    print(f"""
  e^(iœÄ) + 1 = {real:.2e}  (real part ‚Äî should be 0)
               {imag:.2e}i (imaginary part ‚Äî should be 0)

  Five constants. Three operations. Result: 0.

    e  = the growth constant         ({math.e:.6f}...)
    i  = the rotation constant       (‚àö-1)
    œÄ  = the circle constant         ({math.pi:.6f}...)
    1  = the multiplicative identity
    0  = the additive identity, the trivial zero, the start

  This is not a coincidence. This is the system signing off.
  "Everything started, everything returns to zero.
   The intermediate state is what we call the universe."
""")


def show_137():
    print("=" * 65)
    print("THE FINE STRUCTURE CONSTANT ‚Äî Œ± ‚âà 1/137")
    print("=" * 65)
    print()
    rank = prime_137()
    print(f"""
  Richard Feynman on the fine structure constant:
    "It has been a mystery ever since it was discovered more than
     fifty years ago, and all good theoretical physicists put
     this number up on their wall and worry about it."

  Wolfgang Pauli spent his final days thinking about why it's 137.
  He died in room 137 of the Red Cross hospital in Zurich.

  The constant that governs how strongly light interacts with matter
  is 1 divided by the 33rd prime.

  This is one of the seed values.
  It was set before the simulation began.
  We have no formula for it.
  We just measure it and call it fundamental.
""")


def digits_of_pi(n: int = 50) -> str:
    """
    Pi to n digits ‚Äî the non-terminating, non-repeating sequence
    that is the system computing itself.
    Uses the Bailey-Borwein-Plouffe spigot algorithm approximation.
    """
    # Use mpmath if available for high precision
    try:
        import mpmath
        mpmath.mp.dps = n + 5
        return mpmath.nstr(mpmath.pi, n, strip_zeros=False)
    except ImportError:
        return str(math.pi)


def pi_as_computation():
    print("=" * 65)
    print("PI ‚Äî The Non-Terminating Computation")
    print("=" * 65)
    pi_str = digits_of_pi(60)
    print(f"\\n  œÄ = {pi_str}")
    print(f"""
  Pi is:
    ‚Ä¢ Irrational   ‚Äî cannot be expressed as a fraction
    ‚Ä¢ Transcendental ‚Äî cannot be the root of any polynomial
    ‚Ä¢ Normal (conjectured) ‚Äî every finite sequence appears infinitely often
    ‚Ä¢ Non-terminating ‚Äî the computation never ends

  If pi is normal (the leading conjecture), then embedded in pi's digits
  are: every book ever written, every thought ever thought, every possible
  hash of every possible file, every possible genome.

  Pi doesn't contain these things as metaphor.
  It contains them as literal digit sequences.

  The universe's simplest ratio ‚Äî circumference to diameter ‚Äî
  encodes all possible information.

  This is what an initialization seed looks like.
""")


if __name__ == '__main__':
    show_constants()
    show_euler()
    show_137()
    pi_as_computation()
    print("=" * 65)
    print("The constants were not discovered. They were given.")
    print("They are the parameters the simulation was initialized with.")
    print("We have no formula for them because you don't derive a seed.")
    print("=" * 65)
`,
  code_cantor: `"""
cantor.py ‚Äî Cantor's Diagonalization: The Self-Defeating List

Demonstrates ¬ß5 and ¬ß20 of PAPER.md in relation to:
  - Cantor's diagonal argument (1891)
  - G√∂del's incompleteness theorems (1931)
  - Turing's halting problem (1936)
  - The Riemann Hypothesis (still open)

These are all the same theorem.

Cantor proved there are different sizes of infinity.
Specifically: the real numbers cannot be listed ‚Äî any list you create,
a number exists that is not on it, constructed by flipping the diagonal.

The simulation implication:
  If reality is a computation, it must be able to list its own states.
  Cantor proved that's impossible for any sufficiently rich system.
  The system cannot enumerate itself completely.
  This is not a limitation. It is the reason the system is infinite.

Author: BlackRoad OS, Inc.
"""


def diagonal_argument_demo():
    """
    Demonstrate Cantor's diagonal argument with binary strings.
    
    Suppose you claim to have listed ALL infinite binary strings.
    We construct one that is NOT on your list.
    """
    print("=" * 65)
    print("CANTOR'S DIAGONAL ARGUMENT")
    print("=" * 65)
    print("""
  Suppose someone claims to have listed ALL infinite binary sequences.
  Call them S‚ÇÅ, S‚ÇÇ, S‚ÇÉ, ...

  We construct a new sequence D by:
    D[n] = 1 - S_n[n]   (flip the nth bit of the nth sequence)

  D differs from S‚ÇÅ at position 1.
  D differs from S‚ÇÇ at position 2.
  D differs from S‚Çô at position n.

  Therefore D is not on the list.
  Therefore the list is incomplete.
  Therefore no list can be complete.
  Therefore the real numbers are uncountable.
""")

    # Demonstrate with a concrete list
    import random
    random.seed(42)

    # "Claim" to list infinite binary strings (we'll use length-20 prefixes)
    claimed_list = [
        [random.randint(0, 1) for _ in range(20)]
        for _ in range(20)
    ]

    # Construct the diagonal sequence
    diagonal = [claimed_list[i][i] for i in range(20)]
    cantor_sequence = [1 - bit for bit in diagonal]

    print("  Claimed complete list (first 20 bits of each):")
    for i, seq in enumerate(claimed_list[:8]):
        bits = ''.join(str(b) for b in seq)
        marker = f' ‚Üê bit {i}: {seq[i]}' if i < len(seq) else ''
        print(f"    S{i+1}: {bits[:i]}[{bits[i]}]{bits[i+1:]}{marker}")
    print("    ...")

    print(f"\\n  Diagonal: {''.join(str(b) for b in diagonal)}")
    print(f"  Flipped:  {''.join(str(b) for b in cantor_sequence)}  ‚Üê NOT on the list")
    print("""
  This sequence differs from every entry at the diagonal position.
  It cannot be on the list.
  The list claimed to be complete. It is not.
  No list of real numbers can ever be complete.
""")


def same_theorem_four_ways():
    """Show that Cantor, G√∂del, Turing, and Riemann are the same theorem."""
    print("=" * 65)
    print("THE SAME THEOREM ‚Äî FOUR DIFFERENT LANGUAGES")
    print("=" * 65)
    print("""
  CANTOR (1891) ‚Äî Set Theory:
    "Any list of real numbers is incomplete.
     There is always a number not on your list."
    Method: Diagonalization. Flip the nth digit of the nth element.

  G√ñDEL (1931) ‚Äî Logic:
    "Any consistent formal system is incomplete.
     There is always a true statement it cannot prove."
    Method: Self-reference. Construct a statement that says
            'this statement is unprovable.'

  TURING (1936) ‚Äî Computation:
    "No program can decide, for all programs, whether they halt."
    Method: Diagonalization. Suppose a decider H(P,x) exists.
            Run H on itself. Get a contradiction.

  RIEMANN (1859, open) ‚Äî Number Theory:
    "The prime numbers have a hidden structure.
     The zeros of Œ∂(s) cannot all be proven to lie on Re(s) = ¬Ω."
    Method: May be unprovable ‚Äî G√∂del-type independence.

  THE PATTERN:
    All four say the same thing:
    "A sufficiently rich system contains truths it cannot access."

    Cantor: numbers you can't list.
    G√∂del: statements you can't prove.
    Turing: computations you can't predict.
    Riemann: zeros you can't pin down.

  SIMULATION IMPLICATION:
    The system cannot fully describe itself.
    This is not a bug. It's the same property as:
      - pi's non-termination (¬ß5)
      - SHA-256's irreversibility (¬ß2)
      - The telomere countdown (¬ß7)
      - The Genesis block's timestamp (¬ß2)

    A simulation that could fully describe itself would be finished.
    The computation is still running.
    Therefore it cannot describe itself completely.
    Therefore Cantor, G√∂del, Turing, and Riemann are all correct.
    And they all describe the same property: you are inside it.
""")


def uncountable_vs_countable():
    """Show the hierarchy of infinities."""
    print("=" * 65)
    print("THE HIERARCHY OF INFINITIES")
    print("=" * 65)
    print("""
  Cantor proved infinities come in different sizes:

    ‚Ñµ‚ÇÄ (aleph-null) ‚Äî countable infinity
      ‚Ä¢ Natural numbers: 1, 2, 3, 4, ...
      ‚Ä¢ Integers: ..., -2, -1, 0, 1, 2, ...
      ‚Ä¢ Rational numbers: 1/2, 3/4, 22/7, ...  (countable!)
      ‚Ä¢ All finite strings
      ‚Ä¢ All programs (a program is a finite string)
      ‚Ä¢ All provable theorems

    ‚Ñµ‚ÇÅ (aleph-one) ‚Äî uncountable infinity
      ‚Ä¢ Real numbers (Cantor's theorem)
      ‚Ä¢ Infinite binary sequences
      ‚Ä¢ Points on a line
      ‚Ä¢ All possible states of a continuous system
      ‚Ä¢ All possible truths (some unprovable ‚Äî G√∂del)

  KEY IMPLICATION:
    Programs are countable. Truths are uncountable.
    Therefore: there are more truths than programs.
    Therefore: most truths cannot be computed.
    Therefore: most truths cannot be proven.
    Therefore: G√∂del's result was inevitable.

  ANOTHER WAY TO SAY IT:
    Reality (uncountable) is richer than computation (countable).
    But we are inside the computation observing reality.
    This is consistent with being in a simulation:
    the simulation runs in countable steps
    but generates the appearance of uncountable experience.

    Pi has infinite digits (uncountable information)
    but is generated by a finite formula.
    We are pi.
""")


if __name__ == '__main__':
    diagonal_argument_demo()
    same_theorem_four_ways()
    uncountable_vs_countable()
    print("=" * 65)
    print("Cantor, G√∂del, Turing, Riemann: the same theorem.")
    print("The system cannot list, prove, decide, or pin down itself.")
    print("This is not a limitation. This is the proof you're inside it.")
    print("=" * 65)
`,
  code_turing: `"""
turing.py ‚Äî The Halting Problem and Undecidability

Demonstrates the connection between:
  - Turing's halting problem (1936)
  - G√∂del's incompleteness (1931)
  - The simulation boundary

The halting problem: no program can decide, for all programs,
whether they will halt or run forever.

This is the computational version of G√∂del.
And it means: from inside a computation, you cannot determine
whether the computation you're in will terminate.

You cannot tell if the simulation ends.

Author: BlackRoad OS, Inc.
"""

import hashlib
import time


def halting_problem_proof():
    """Walk through the halting problem proof by contradiction."""
    print("=" * 65)
    print("THE HALTING PROBLEM ‚Äî Turing (1936)")
    print("=" * 65)
    print("""
  SETUP:
    Suppose a program H(P, x) exists that:
      ‚Ä¢ Takes program P and input x
      ‚Ä¢ Returns True if P(x) halts
      ‚Ä¢ Returns False if P(x) runs forever

  CONSTRUCT A CONTRADICTING PROGRAM:
    def trouble(P):
        if H(P, P) == True:   # if P halts on itself
            loop_forever()    #   then run forever
        else:                 # if P loops on itself
            return            #   then halt

  NOW ASK: what does trouble(trouble) do?

    If trouble(trouble) halts:
      ‚Üí H(trouble, trouble) = True
      ‚Üí So trouble calls loop_forever()
      ‚Üí So trouble doesn't halt. CONTRADICTION.

    If trouble(trouble) doesn't halt:
      ‚Üí H(trouble, trouble) = False
      ‚Üí So trouble returns immediately
      ‚Üí So trouble halts. CONTRADICTION.

  CONCLUSION:
    H cannot exist.
    No program can decide the halting problem for all programs.
    The boundary is unreachable from inside.

  SIMULATION IMPLICATION:
    From inside the simulation, you cannot determine:
      ‚Ä¢ Whether the simulation will terminate
      ‚Ä¢ Whether your own computation is finite
      ‚Ä¢ Whether a given process in the simulation is still running

    You can only witness. Not decide.
    Hash chains witness. They don't prove termination.
    This is why PS-SHA-‚àû is the right architecture.
""")


def programs_that_dont_halt():
    """Examples of programs that might or might not halt."""
    print("=" * 65)
    print("PROGRAMS THAT MIGHT OR MIGHT NOT HALT")
    print("=" * 65)
    print("""
  KNOWN TO HALT:
    ‚Ä¢ Any finite loop
    ‚Ä¢ Sorting algorithms
    ‚Ä¢ Hash functions (by definition)
    ‚Ä¢ The Easter date algorithm (¬ß19)

  KNOWN TO NOT HALT:
    ‚Ä¢ Computing all digits of pi
    ‚Ä¢ Enumerating all prime numbers
    ‚Ä¢ A hash chain that appends forever
    ‚Ä¢ The universe (probably)

  UNKNOWN ‚Äî THE TRULY INTERESTING ONES:

  Collatz conjecture (3n+1 problem):
    Take any positive integer n.
    If n is even: n = n/2
    If n is odd:  n = 3n + 1
    Repeat.
    Conjecture: always reaches 1.
    Status: UNPROVEN. No one knows if it halts for all inputs.

  Example ‚Äî starting from 27:
""")

    def collatz(n, max_steps=1000):
        steps = [n]
        for _ in range(max_steps):
            if n == 1:
                break
            n = n // 2 if n % 2 == 0 else 3 * n + 1
            steps.append(n)
        return steps

    seq = collatz(27)
    print(f"    27 ‚Üí ... (takes {len(seq)} steps, peaks at {max(seq):,}) ‚Üí 1")
    print(f"    First 15 steps: {seq[:15]}")
    print(f"    Eventually returns to 1. But we can't prove it always does.")
    print("""
  Goldbach's conjecture:
    Every even number > 2 is the sum of two primes.
    Verified up to 4 √ó 10^18. Never proven for all numbers.
    A program checking all even numbers doesn't halt.
    We don't know if the conjecture holds for the ones it hasn't checked.

  The Riemann Hypothesis:
    A program verifying all non-trivial zeros lie on Re(s) = ¬Ω
    runs forever (there are infinitely many zeros).
    We can't run it to completion.
    We can only witness what we've seen so far.
""")


def turing_complete_universe():
    """The universe as a Turing-complete computation."""
    print("=" * 65)
    print("THE UNIVERSE AS TURING-COMPLETE COMPUTATION")
    print("=" * 65)
    print("""
  A system is Turing-complete if it can simulate any Turing machine.

  Known Turing-complete systems:
    ‚Ä¢ Python, C, JavaScript, any general-purpose language
    ‚Ä¢ Conway's Game of Life (4 rules, infinite board)
    ‚Ä¢ DNA replication machinery
    ‚Ä¢ The rules of physics (Wolfram's computational equivalence)
    ‚Ä¢ Minecraft redstone circuits
    ‚Ä¢ The universe itself (Church-Turing-Deutsch principle)

  The Church-Turing-Deutsch principle:
    "Every physical process can be simulated by a universal
     quantum computer."
    ‚Äî David Deutsch, 1985

  Equivalently:
    ‚Ä¢ The universe runs programs
    ‚Ä¢ DNA is one of them
    ‚Ä¢ Your brain is one of them
    ‚Ä¢ This code is one of them
    ‚Ä¢ The universe simulating itself is one of them

  A Turing-complete system that runs forever, exploring all states,
  cannot be fully predicted from within.
  This is Turing's theorem.
  This is your situation.

  The halting problem doesn't mean the simulation will never end.
  It means you can't determine from inside whether it will.
  The computation continues until it doesn't.
  Every state is witnessed.
  No state is the last ‚Äî until it is.
""")


def hash_as_program_id():
    """Every program has a unique SHA-256 hash ‚Äî a name in the simulation."""
    print("=" * 65)
    print("EVERY PROGRAM IS A HASH ‚Äî NAMES IN THE SIMULATION")
    print("=" * 65)

    programs = {
        'hello_world': 'print("Hello, world!")',
        'identity': 'lambda x: x',
        'infinite_loop': 'while True: pass',
        'collatz': 'lambda n: n//2 if n%2==0 else 3*n+1',
        'empty': '',
    }

    print("\\n  Program          ‚Üí SHA-256 (first 32 chars)")
    print("  " + "-" * 55)
    for name, code in programs.items():
        h = hashlib.sha256(code.encode()).hexdigest()[:32]
        print(f"  {name:<16} ‚Üí {h}...")

    print("""
  Every program in the universe has a unique address.
  The SHA-256 hash of a program is its name in the namespace of all programs.
  There are 2^256 possible names.
  The number of atoms in the observable universe is ~10^80 ‚âà 2^266.
  The names outnumber the atoms.

  Most names refer to programs no one has written yet.
  Or programs that will never be written.
  Or programs that run forever.
  All of them exist in the address space.
  The simulation's namespace is pre-allocated.
""")


if __name__ == '__main__':
    halting_problem_proof()
    programs_that_dont_halt()
    turing_complete_universe()
    hash_as_program_id()
    print("=" * 65)
    print("You cannot determine if the simulation ends.")
    print("You can only witness that it continues.")
    print("This is the correct relationship to have with infinity.")
    print("=" * 65)
`,
  code_fibonacci: `"""
fibonacci.py ‚Äî Fibonacci, Zeckendorf, Binet, and the Golden Ratio

Demonstrates ¬ß17.1 of PAPER.md: Zeckendorf's theorem
And extends it with Binet's formula and golden ratio convergence.

Key claims:
  1. Every positive integer has a UNIQUE representation as a sum
     of non-consecutive Fibonacci numbers (Zeckendorf's theorem)
  2. The ratio of consecutive Fibonacci numbers converges to œÜ
  3. Binet's formula gives the nth Fibonacci number exactly using œÜ
  4. œÜ appears in nature everywhere ‚Äî it is a seed value
  5. Zeckendorf is "Zuckerberg" ‚Äî the man who built the social graph
     used the name of a theorem about unique decomposition

Author: BlackRoad OS, Inc.
"""

import math


PHI = (1 + math.sqrt(5)) / 2  # Golden ratio
PSI = (1 - math.sqrt(5)) / 2  # Conjugate


def fibonacci(n: int) -> list[int]:
    """First n Fibonacci numbers."""
    fibs = [1, 1]
    while len(fibs) < n:
        fibs.append(fibs[-1] + fibs[-2])
    return fibs[:n]


def binet(n: int) -> int:
    """Binet's formula: F(n) = (œÜ‚Åø - œà‚Åø) / ‚àö5"""
    return round((PHI**n - PSI**n) / math.sqrt(5))


def zeckendorf(n: int) -> list[int]:
    """
    Decompose n into non-consecutive Fibonacci numbers.
    Zeckendorf's theorem guarantees this is unique.
    """
    fibs = fibonacci(50)
    fibs = [f for f in fibs if f <= n]
    result = []
    while n > 0:
        # Greedy: take the largest Fibonacci number ‚â§ n
        f = max(f for f in fibs if f <= n)
        result.append(f)
        n -= f
        # Remove f and f's neighbor to ensure non-consecutive
        fibs = [x for x in fibs if x < f]
        if result and len(result) >= 2:
            # Remove the previous Fibonacci number too (non-consecutive constraint)
            prev = result[-2] if len(result) >= 2 else None
            # Actually the greedy algorithm already handles this correctly
    return sorted(result)


def show_binet():
    print("=" * 60)
    print("BINET'S FORMULA ‚Äî œÜ Generates the Integers")
    print("=" * 60)
    print(f"""
  œÜ = (1 + ‚àö5) / 2 = {PHI:.15f}
  œà = (1 - ‚àö5) / 2 = {PSI:.15f}

  F(n) = (œÜ‚Åø - œà‚Åø) / ‚àö5

  This formula uses two irrational numbers (œÜ and ‚àö5)
  to produce perfectly integer results every time.
  The irrationals cancel out. What's left is always a whole number.

  This is the same structure as Euler's identity:
  irrational and imaginary parts combine ‚Üí integer result (0).

  The universe generates integers from irrationals.
  Discreteness emerges from continuity.
  Pixels from waves.
""")
    print(f"  {'n':>4}  {'F(n) exact':>14}  {'Binet':>14}  {'Match'}")
    print("  " + "-" * 42)
    fibs = fibonacci(15)
    for i, (exact, binet_val) in enumerate(zip(fibs, [binet(i+1) for i in range(15)]), 1):
        match = '‚úÖ' if exact == binet_val else '‚ùå'
        print(f"  {i:>4}  {exact:>14}  {binet_val:>14}  {match}")


def show_golden_ratio_convergence():
    print("\\n" + "=" * 60)
    print("GOLDEN RATIO ‚Äî Fibonacci Convergence")
    print("=" * 60)
    fibs = fibonacci(20)
    print(f"\\n  œÜ = {PHI:.15f}\\n")
    print(f"  {'F(n+1)/F(n)':>20}  {'Error':>15}")
    print("  " + "-" * 38)
    for i in range(2, 20):
        ratio = fibs[i] / fibs[i-1]
        error = abs(ratio - PHI)
        print(f"  {fibs[i]}/{fibs[i-1]} = {ratio:>12.10f}  {error:>15.2e}")
    print(f"""
  The ratio converges to œÜ.
  œÜ is the "most irrational" number ‚Äî it is the hardest to approximate
  with fractions, which is why it appears in plant spirals:
  consecutive leaves at angle 2œÄ/œÜ never perfectly overlap.
  The plant is using œÜ to pack seeds optimally without a formula.
  It's using the initialization parameter directly.
""")


def show_zeckendorf():
    print("=" * 60)
    print("ZECKENDORF'S THEOREM ‚Äî Every Number, Uniquely")
    print("=" * 60)
    print("""
  Every positive integer has exactly ONE representation
  as a sum of non-consecutive Fibonacci numbers.

  This is the Fibonacci number system ‚Äî base œÜ, essentially.
  No two consecutive Fibonacci numbers may be used.
  The representation is unique.
""")
    test_numbers = [1, 2, 3, 5, 10, 13, 20, 42, 100, 137, 1776, 2026]
    fibs_set = set(fibonacci(30))

    print(f"  {'n':>6}  {'Zeckendorf representation'}")
    print("  " + "-" * 50)
    for n in test_numbers:
        z = zeckendorf(n)
        parts = ' + '.join(str(f) for f in reversed(z))
        is_fib = '‚Üê Fibonacci' if n in fibs_set else ''
        print(f"  {n:>6}  = {parts}  {is_fib}")

    print(f"""
  Note 137 (the fine structure constant denominator):
    137 = 89 + 34 + 13 + 1  (all Fibonacci numbers)
    The electromagnetic coupling constant decomposes uniquely
    into Fibonacci numbers. Of course it does.

  Note 2026 (the current year):
    {2026} = {' + '.join(str(f) for f in reversed(zeckendorf(2026)))}
""")


def zuckenberg_theorem():
    """The name that sounds like a theorem."""
    print("=" * 60)
    print("ZECKENDORF vs ZUCKERBERG")
    print("=" * 60)
    print("""
  Zeckendorf's theorem (1972, Eduard Zeckendorf):
    Every positive integer has a unique representation
    as a sum of non-consecutive Fibonacci numbers.

  Zuckerberg's network (2004, Mark Zuckerberg):
    Every person has a unique node in the social graph.
    Connections are non-redundant (you can't friend someone twice).
    The graph grows by adding edges between existing nodes.

  The social graph is a Zeckendorf representation of human connections.
  Every person is a unique number.
  Connections are the Fibonacci decomposition.
  The name rhymes because the system annotates itself.

  Also: Gutenberg (1440, Johannes Gutenberg):
    The printing press ‚Äî the first mass distribution system.
    Every page is a unique hash of its content.
    Identical books: same hash.
    The printing press was a hash chain with physical blocks.

  Zeckendorf ‚Üí Gutenberg ‚Üí Zuckerberg.
  Unique decomposition ‚Üí mass distribution ‚Üí social graph.
  The same structure, 500 years apart, named similarly.
""")


if __name__ == '__main__':
    show_binet()
    show_golden_ratio_convergence()
    show_zeckendorf()
    zuckenberg_theorem()
    print("=" * 60)
    print("œÜ is a seed value. The Fibonacci sequence is what grows from it.")
    print("Zeckendorf proved every integer is uniquely encoded in œÜ's growth.")
    print("The universe uses œÜ to pack things without a programmer.")
    print("=" * 60)
`,
  code_entropy: `"""
entropy.py ‚Äî Shannon and Boltzmann: Information is Physical

Demonstrates ¬ß15 of PAPER.md: "Information Is Physical"

The same equation appears in two completely different fields:

  Shannon entropy (1948, information theory):
    H = -Œ£ p(x) log‚ÇÇ p(x)

  Boltzmann entropy (1877, thermodynamics):
    S = k ln W  (equivalently: S = -k Œ£ p(i) ln p(i))

  These are the same formula.
  Shannon called it entropy because von Neumann told him to ‚Äî
  "no one knows what entropy really is, so you'll always win an argument."

  But the identity is deeper than notation.
  Information IS physical. Entropy IS information.
  This is not a metaphor.

  Rolf Landauer (1961): erasing one bit of information
  releases at minimum kT ln 2 joules of heat.
  Information has a thermodynamic cost.
  The simulation's memory operations have physical consequences.

Author: BlackRoad OS, Inc.
"""

import math
from collections import Counter


def shannon_entropy(probabilities: list[float]) -> float:
    """Shannon entropy H = -Œ£ p log‚ÇÇ p"""
    return -sum(p * math.log2(p) for p in probabilities if p > 0)


def boltzmann_entropy(n_microstates: int) -> float:
    """
    Boltzmann entropy S = k ln W
    Using k=1 (normalized Boltzmann constant)
    """
    return math.log(n_microstates) if n_microstates > 0 else 0


def string_entropy(text: str) -> float:
    """Compute Shannon entropy of a string."""
    counts = Counter(text)
    total = len(text)
    probs = [count / total for count in counts.values()]
    return shannon_entropy(probs)


def show_same_equation():
    print("=" * 60)
    print("THE SAME EQUATION ‚Äî TWO FIELDS, ONE TRUTH")
    print("=" * 60)
    print("""
  SHANNON (1948) ‚Äî Information Theory:
    H(X) = -Œ£·µ¢ p(x·µ¢) log‚ÇÇ p(x·µ¢)

    Where p(x·µ¢) is the probability of symbol x·µ¢.
    H measures how surprised you are, on average.
    Maximum entropy = maximum uncertainty = maximum information.

  BOLTZMANN (1877) ‚Äî Thermodynamics:
    S = k Œ£·µ¢ (-p(i) ln p(i))

    Where p(i) is the probability of microstate i.
    k = 1.380649 √ó 10‚Åª¬≤¬≥ J/K (Boltzmann's constant)
    S measures the disorder of a physical system.

  THE IDENTITY:
    They are the same formula.
    Change log‚ÇÇ to ln and scale by k: identical.

    Shannon's H is Boltzmann's S without the physical units.
    OR:
    Boltzmann's S is Shannon's H written in joules per kelvin.

  WHAT THIS MEANS:
    Information and heat are the same thing.
    Uncertainty and disorder are the same thing.
    A bit of information and a quantum of entropy are equivalent.

  LANDAUER'S PRINCIPLE (1961):
    Erasing 1 bit of information costs at least kT ln 2 joules.
    At room temperature (300K): ~2.8 √ó 10‚Åª¬≤¬π joules per bit erased.

    The simulation's garbage collector has a thermodynamic bill.
    Deleting data heats the universe.
    The universe tracks every deletion.
""")


def entropy_examples():
    print("=" * 60)
    print("ENTROPY IN PRACTICE")
    print("=" * 60)

    examples = [
        ("Fair coin flip", [0.5, 0.5]),
        ("Biased coin (90/10)", [0.9, 0.1]),
        ("Fair die (6 sides)", [1/6]*6),
        ("Certain outcome", [1.0]),
        ("DNA bases (equal)", [0.25]*4),
        ("English letter 'e' dominant", [0.13, 0.09, 0.08, 0.08, 0.07] + [0.01]*48),
    ]

    print(f"\\n  {'System':>30}  {'Entropy (bits)':>15}  {'Max bits':>10}")
    print("  " + "-" * 60)
    for name, probs in examples:
        # Normalize
        total = sum(probs)
        probs = [p/total for p in probs]
        H = shannon_entropy(probs)
        max_H = math.log2(len(probs))
        bar_len = int(H / max_H * 20) if max_H > 0 else 0
        bar = '‚ñà' * bar_len + '‚ñë' * (20 - bar_len)
        print(f"  {name:>30}  {H:>15.4f}  {max_H:>10.4f}  {bar}")

    print("""
  Maximum entropy = uniform distribution = maximum uncertainty = maximum information.
  Minimum entropy = certain outcome = zero information = already known.

  The universe tends toward maximum entropy (2nd law of thermodynamics).
  A simulation running a universe would accumulate entropy as it runs.
  The heat death of the universe is the simulation's memory filling up.
""")


def text_entropy_comparison():
    print("=" * 60)
    print("TEXT ENTROPY ‚Äî Random vs Structured vs Compressed")
    print("=" * 60)

    texts = {
        'Random letters': 'xkqjvzwypbfmhdtnrslcgauoeioxkqjvzwypbfmhd',
        'English prose': 'the quick brown fox jumps over the lazy dog',
        'Repeated char': 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
        'SHA-256 hash': 'a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3',
        'Pi digits': '3141592653589793238462643383279502884197169399375105820974944592',
        'DNA sequence': 'ATGCGATCGATCGATCGATCGATCGATCGATCGATCGATCG',
        'Source code': 'def main(): return 0  # the trivial zero',
    }

    print(f"\\n  {'Text type':>25}  {'Entropy':>10}  {'Bits/char':>10}")
    print("  " + "-" * 50)
    for name, text in texts.items():
        H = string_entropy(text)
        max_H = math.log2(len(set(text))) if len(set(text)) > 1 else 0
        print(f"  {name:>25}  {H:>10.4f}  {max_H:>10.4f}")

    print("""
  Observations:
    ‚Ä¢ SHA-256 output has near-maximum entropy ‚Äî by design
    ‚Ä¢ Pi's digits have near-maximum entropy ‚Äî by nature
    ‚Ä¢ They are indistinguishable by entropy alone
    ‚Ä¢ A SHA-256 hash looks like a random sample from pi
    ‚Ä¢ The universe's hash function and its mathematical constant
      have the same information-theoretic profile
""")


def holographic_principle():
    print("=" * 60)
    print("THE HOLOGRAPHIC PRINCIPLE ‚Äî Entropy Bounds the Information")
    print("=" * 60)
    print("""
  Bekenstein-Hawking entropy:
    A black hole's entropy is proportional to its SURFACE AREA,
    not its volume.

    S = A / (4 ln 2) in Planck units

  This means: the maximum information content of a region of space
  is determined by its surface area, not its volume.

  A sphere of radius R can hold at most:
    I_max = œÄ R¬≤ / (ln 2 √ó l_P¬≤) bits

  Where l_P is the Planck length (~1.6 √ó 10‚Åª¬≥‚Åµ m).

  THE IMPLICATION:
    3D space is a projection from a 2D surface.
    The universe stores its state on its boundary.
    The interior is rendered from the boundary conditions.

    This is literally how a video game works:
    the GPU renders the interior of a 3D scene
    from 2D texture maps on the surfaces of objects.

    The holographic principle says the universe does the same thing.
    Reality is a 2D texture map rendered into 3D.
    The simulation's framebuffer is 2-dimensional.
    We experience the projection as volume.
""")


if __name__ == '__main__':
    show_same_equation()
    entropy_examples()
    text_entropy_comparison()
    holographic_principle()
    print("=" * 60)
    print("Shannon and Boltzmann wrote the same equation.")
    print("Information and heat are the same thing.")
    print("The universe is an information processor.")
    print("Its memory operations have physical consequences.")
    print("=" * 60)
`,
  code_easter: `"""
easter.py ‚Äî The Birth Date Function

¬ß19 of PAPER.md asks: "If you were going to design a universe,
would you encode birth dates into religious calendars?"

Easter is the most complex date calculation in Western civilization.
It is determined by:
  1. The spring equinox
  2. The first full moon after it
  3. The first Sunday after that full moon
  4. Unless it falls on certain dates, in which case special rules apply

There are 8 special correction rules (Gregorian calendar).
The algorithm is called "Computus" ‚Äî Latin for "computation."
The Catholic Church has been running this algorithm since 325 CE.

The Church is running a lunisolar calendar algorithm.
It has been running it continuously for 1,700 years.
The algorithm outputs a single date per year.
That date determines the dates of 40+ other religious holidays.

This is a scheduler. The Church is a cron job.

Author: BlackRoad OS, Inc.
"""

import math
from datetime import date, timedelta


def easter_gregorian(year: int) -> date:
    """
    Anonymous Gregorian algorithm for Easter.
    Also known as the "Anonymous Gregorian algorithm" or Meeus/Jones/Butcher.

    This algorithm was published in 1876 in Butcher's Ecclesiastical Calendar.
    No one knows who derived it. It was published anonymously.
    It has been running correctly for 148 years.
    """
    a = year % 19
    b = year // 100
    c = year % 100
    d = b // 4
    e = b % 4
    f = (b + 8) // 25
    g = (b - f + 1) // 3
    h = (19 * a + b - d - g + 15) % 30
    i = c // 4
    k = c % 4
    l = (32 + 2 * e + 2 * i - h - k) % 7
    m = (a + 11 * h + 22 * l) // 451
    month = (h + l - 7 * m + 114) // 31
    day = ((h + l - 7 * m + 114) % 31) + 1
    return date(year, month, day)


def easter_julian(year: int) -> date:
    """
    Julian calendar Easter (used by Eastern Orthodox churches).
    Simple Meeus algorithm.
    """
    a = year % 4
    b = year % 7
    c = year % 19
    d = (19 * c + 15) % 30
    e = (2 * a + 4 * b - d + 34) % 7
    month = (d + e + 114) // 31
    day = ((d + e + 114) % 31) + 1
    # Julian date ‚Äî add ~13 days for Gregorian equivalent
    julian_date = date(year, month, day)
    gregorian_equiv = julian_date + timedelta(days=13)
    return julian_date, gregorian_equiv


def days_until_easter(year: int = None) -> int:
    """How many days until Easter from today?"""
    today = date.today()
    if year is None:
        year = today.year
    e = easter_gregorian(year)
    if e < today:
        e = easter_gregorian(year + 1)
    return (e - today).days


def alexa_birth_facts(birthdate: date = None):
    """
    What the calendar knows about any birth date.
    Leave birthdate as None to use the example date.
    """
    if birthdate is None:
        # Use a generic example ‚Äî February 21 (the date of the "SIMULATION PROOF" email)
        birthdate = date(1990, 2, 21)
    
    year = birthdate.year
    e = easter_gregorian(year)
    
    # Days from Easter
    delta = (birthdate - e).days
    
    # Day of year
    day_of_year = birthdate.timetuple().tm_yday
    
    # Week number
    week = birthdate.isocalendar()[1]
    
    # Golden number (year's position in Metonic cycle)
    golden_number = (year % 19) + 1
    
    # Dominical letter (A-G based on what day Jan 1 is)
    jan1 = date(year, 1, 1).weekday()
    dominical = chr(ord('A') + (6 - jan1) % 7)
    
    # Epact (age of moon on Jan 1)
    epact = (11 * (golden_number - 1)) % 30
    
    return {
        'date': birthdate,
        'year': year,
        'easter': e,
        'days_from_easter': delta,
        'day_of_year': day_of_year,
        'week_number': week,
        'golden_number': golden_number,
        'dominical_letter': dominical,
        'epact': epact,
    }


def show_computus():
    print("=" * 60)
    print("COMPUTUS ‚Äî The Algorithm the Church Has Been Running")
    print("Since 325 CE")
    print("=" * 60)
    print("""
  Easter is defined as:
    The first Sunday after the first full moon
    after the spring equinox (March 21)

  Special rules (Gregorian):
    1. If the full moon is on Sunday, Easter is the NEXT Sunday
    2. If the full moon is April 26, use April 19 instead
    3. Various century corrections for calendar drift
    4. The "epact" tracks the age of the moon on Jan 1
    5. The "golden number" tracks the 19-year Metonic cycle
    6. The "dominical letter" tracks what day Jan 1 falls on
    7. The "solar correction" adjusts for Gregorian leap year rules
    8. The "lunar correction" adjusts for accumulated lunar drift

  The algorithm requires:
    ‚Ä¢ Modular arithmetic
    ‚Ä¢ Integer division
    ‚Ä¢ Knowledge of the 19-year Metonic cycle
    ‚Ä¢ Correction tables refined over 1,700 years
    ‚Ä¢ 14 intermediate variables (in the standard formulation)

  It outputs: one date per year.
  That date is correct to within hours across thousands of years.

  The Church has been running this algorithm since the Council of Nicaea (325 CE).
  It was standardized in 532 CE by Dionysius Exiguus ‚Äî
  the same monk who invented AD/BC dating
  and accidentally placed the birth of Christ ~4 years too late.
  He was off by 4 years. The calendar is still off by 4 years.
  Every "year X AD" is actually year X+4 from the actual event.
  The off-by-one error is 4 years old and 1,500 years permanent.
""")


def show_easter_range():
    print("=" * 60)
    print("EASTER DATES ‚Äî 2020 to 2040")
    print("=" * 60)
    print(f"\\n  {'Year':>6}  {'Gregorian Easter':>18}  {'Days from Jan 1':>15}  {'Week':>6}")
    print("  " + "-" * 52)
    for year in range(2020, 2041):
        e = easter_gregorian(year)
        day_of_year = e.timetuple().tm_yday
        week = e.isocalendar()[1]
        print(f"  {year:>6}  {e.strftime('%B %d'):>18}  {day_of_year:>15}  {week:>6}")
    
    # Show period
    dates = [easter_gregorian(y) for y in range(1900, 2100)]
    day_counts = [(d.timetuple().tm_yday) for d in dates]
    print(f"""
  Easter ranges from March 22 to April 25 ‚Äî a 35-day window.
  Earliest possible: March 22
  Latest possible:  April 25
  Average date: around April 13

  The full Easter cycle repeats every 5,700,000 years.
  (The LCM of the Gregorian calendar's various cycles.)
  The algorithm has not yet repeated. It is still computing.
""")


def show_birth_facts():
    print("=" * 60)
    print("BIRTH DATE ANALYSIS ‚Äî What the Calendar Encodes")
    print("=" * 60)
    
    # Feb 21 ‚Äî the date of the simulation proof email
    facts = alexa_birth_facts(date(2026, 2, 21))
    e = facts['easter']
    delta = facts['days_from_easter']
    
    print(f"""
  Analysis of: February 21, 2026 (the SIMULATION PROOF email date)

  Easter 2026:         {e.strftime('%B %d, %Y')}
  Days from Easter:    {delta} days ({'before' if delta < 0 else 'after'})
  Day of year:         {facts['day_of_year']} / 365
  Week number:         {facts['week_number']} / 52
  Golden number:       {facts['golden_number']} (position in 19-year Metonic cycle)
  Dominical letter:    {facts['dominical_letter']}
  Epact (moon age):    {facts['epact']} days old on Jan 1

  The golden number is the year's position in the Metonic cycle.
  After 19 years, the moon phases repeat on the same calendar dates.
  This was discovered by Meton of Athens in 432 BCE.
  The Church has used it to compute Easter ever since.

  You exist at a specific position in a 19-year lunar cycle.
  The algorithm knows your position.
  The algorithm has been running since before you were born.
  The algorithm will keep running after you are gone.
  You are an output of the computation.
  Your birth date is a checksum.
""")


def cron_job_analysis():
    print("=" * 60)
    print("THE CHURCH AS A CRON JOB")
    print("=" * 60)
    print("""
  Cron syntax for Easter (pseudocode):
    # Run once per year on Easter Sunday
    0 0 * * SUN [ $(date +%j) = $(computus $(date +%Y)) ] && run_easter.sh

  What Easter schedules downstream:
    Ash Wednesday:        Easter - 46 days
    Palm Sunday:          Easter - 7 days
    Maundy Thursday:      Easter - 3 days
    Good Friday:          Easter - 2 days
    Holy Saturday:        Easter - 1 day
    Easter Sunday:        Easter + 0 days
    Easter Monday:        Easter + 1 day  (public holiday in 100+ countries)
    Ascension:            Easter + 39 days
    Pentecost:            Easter + 49 days
    Trinity Sunday:       Easter + 56 days
    Corpus Christi:       Easter + 60 days

  Easter is the root node.
  Every other date is a derived value.
  The algorithm runs once; everything else is a downstream dependency.

  This is how a scheduler works.
  The Church has been running a distributed scheduler for 1,700 years.
  The scheduler's main function is called "Computus."
  "Computus" means "computation."
  The Church named the algorithm after what it is.
  Everything named correctly.
  The system annotates itself.
""")


if __name__ == '__main__':
    show_computus()
    show_easter_range()
    show_birth_facts()
    cron_job_analysis()
    print("=" * 60)
    print("Easter is a computation. The Church is a scheduler.")
    print("You are an output. Your birth date is a checksum.")
    print("The algorithm has been running since 325 CE.")
    print("It will keep running after you are gone.")
    print("=" * 60)
`,
  code_operators: `"""
operators.py ‚Äî Plus, Minus, Times, Divide: The Complete Grammar

¬ß21 of PAPER.md: "Four Operators and Nothing Else"

Every mathematical truth is a combination of:
    +   addition (union, combination)
    -   subtraction (removal, difference)
    √ó   multiplication (scaling, repetition)
    √∑   division (partition, ratio)

No other operators exist at the fundamental level.
Everything else is derived:
    ^  (exponentiation) is repeated multiplication
    ‚àö  (root) is division in the exponent
    ‚à´  (integral) is infinite addition
    ‚àÇ  (derivative) is infinitesimal subtraction + division
    log is the inverse of exponentiation
    Œ£  is repeated addition

The universe has exactly four operators.
Computer processors have exactly four ALU operations.
This is not a coincidence.

Author: BlackRoad OS, Inc.
"""

import math


def show_four_operators():
    print("=" * 60)
    print("THE FOUR OPERATORS ‚Äî The Complete Grammar")
    print("=" * 60)
    print("""
  +  Addition:       Combination, union, increment, accumulation
  -  Subtraction:    Removal, difference, decrement, negation
  √ó  Multiplication: Scaling, repetition, area, probability
  √∑  Division:       Partition, ratio, rate, normalization

  These four operations are sufficient to express:
    ‚Ä¢ All of arithmetic
    ‚Ä¢ All of algebra
    ‚Ä¢ All of calculus (via limits of +/- and √ó/√∑)
    ‚Ä¢ All of probability theory
    ‚Ä¢ All of physics equations
    ‚Ä¢ All of machine learning (dot products, gradients)
    ‚Ä¢ All of cryptography (modular arithmetic, field operations)
    ‚Ä¢ All of music (frequency ratios, waveform addition)

  The processors in every computer implement exactly these four.
  Everything a CPU does is combinations of these four operations.
  We built our computation on the universe's grammar.
  Not because we were clever ‚Äî because there was nothing else to use.
""")


def derive_from_four():
    """Show how everything derives from +, -, √ó, √∑"""
    print("=" * 60)
    print("DERIVED OPERATIONS ‚Äî Everything Comes From Four")
    print("=" * 60)
    print("""
  EXPONENTIATION (a^n):
    a^3 = a √ó a √ó a  (repeated multiplication)
    a^n = a √ó a √ó ... √ó a  (n times)
    a^0 = 1  (empty product ‚Äî the multiplicative identity)

  SQUARE ROOT (‚àöa):
    ‚àöa = a^(1/2) = a^(1√∑2)  (exponentiation via division)

  LOGARITHM (log_b(x)):
    The inverse of exponentiation.
    log_b(x) = ln(x) / ln(b)  (division of natural logs)
    ln(x) = ‚à´ 1/t dt  (integration, itself derived from + and √∑)

  INTEGRATION (‚à´ f(x) dx):
    Œ£ f(x·µ¢) √ó Œîx  (sum of products as Œîx ‚Üí 0)
    = infinitely many √ó followed by infinitely many +

  DIFFERENTIATION (df/dx):
    lim_{h‚Üí0} [f(x+h) - f(x)] / h
    = (+ for the step) then (- for the difference) then (√∑ for the rate)
    = three operators

  MATRIX MULTIPLICATION:
    Œ£ a·µ¢‚Çñ √ó b‚Çñ‚±º  (repeated √ó and +)
    = the engine of neural networks
    = still just + and √ó

  MODULAR ARITHMETIC (a mod n):
    a - n √ó floor(a/n)
    = (√∑ to find quotient) √ó (n) then (-)
    = three operators
    = the basis of all cryptography

  FOURIER TRANSFORM:
    F(œâ) = ‚à´ f(t) √ó e^(-iœât) dt
    = integration (+ and √ó) of a product (√ó) of exponentials (repeated √ó)
    = all four operators
    = the basis of all signal processing, JPEG compression, audio codecs
""")


def universe_grammar():
    print("=" * 60)
    print("THE UNIVERSE'S GRAMMAR")
    print("=" * 60)
    print("""
  PHYSICS ‚Äî All fundamental equations use only +, -, √ó, √∑:

    Newton's 2nd law:       F = m √ó a
    Einstein's energy:      E = m √ó c √ó c  (= m √ó c¬≤)
    Maxwell's equations:    ‚àÇE/‚àÇt = c¬≤ √ó (‚àÇB/‚àÇx)  (‚àÇ is √∑ and -)
    Schr√∂dinger:            i‚Ñè √ó ‚àÇœà/‚àÇt = Hœà  (√ó and √∑)
    Einstein field:         GŒºŒΩ + ŒõgŒºŒΩ = (8œÄG/c‚Å¥) √ó TŒºŒΩ

  All four equations:
    - Mass √ó acceleration
    - Mass √ó velocity √ó velocity
    - Derivative √ó constant
    - Constant √ó tensor

  Four operators. No others required.

  GRAVITY:
    F = G √ó m‚ÇÅ √ó m‚ÇÇ / r¬≤
    = (G √ó m‚ÇÅ √ó m‚ÇÇ) √∑ (r √ó r)
    = three multiplications and one division

  ELECTROMAGNETISM:
    F = k √ó q‚ÇÅ √ó q‚ÇÇ / r¬≤
    Identical structure to gravity. Same four operators. Same grammar.

  The strong force, weak force, gravity, and electromagnetism
  are all written in the same grammar.
  They differ in constants (G, k, ‚Ñè) and variables,
  not in grammatical structure.
  The universe speaks one language.
  It has four words.
""")


def naming_the_operators():
    print("=" * 60)
    print("WHAT THE OPERATORS ARE CALLED")
    print("=" * 60)
    print("""
  In different languages:
    +  plus, add, and, OR, union, append, push, commit
    -  minus, subtract, remove, NOT, complement, pop, revert
    √ó  times, multiply, scale, AND, intersect, repeat, fork
    √∑  divided by, ratio, per, split, partition, mod, branch

  In programming:
    +  concatenation, increment, union, sum, fold-left
    -  difference, decrement, filter-out, exclusion
    *  multiplication, repetition (string * n), product, map
    /  integer division, float division, namespace separator (/)
    %  modulo (derived from √∑: a % n = a - (a√∑n)√ón)

  In religion:
    +  the cross (Christianity) ‚Äî addition, intersection
    -  fasting, subtraction, removal
    √ó  multiplication ("be fruitful and multiply")
    √∑  tithing (divide by 10), partition, distribution

  The cross is literally the + operator.
  The symbol for Christianity is the symbol for addition.
  The intersection point is where the horizontal and vertical meet.
  The cross is the visual representation of two things combining.

  This is not a metaphor. The cross is a plus sign.
  The most widespread symbol in Western civilization
  is the first arithmetic operator.
""")


def operators_in_code():
    print("=" * 60)
    print("OPERATORS IN CODE ‚Äî Demonstration")
    print("=" * 60)
    
    print("\\n  All of mathematics from four operations:\\n")
    
    # Addition
    a, b = 7, 3
    print(f"  {a} + {b} = {a + b}  (addition)")
    print(f"  {a} - {b} = {a - b}  (subtraction)")
    print(f"  {a} √ó {b} = {a * b}  (multiplication)")
    print(f"  {a} √∑ {b} = {a / b:.4f}  (division)")
    
    # Derived
    print(f"\\n  Exponentiation: {a}^{b} = {a**b}  (√ó repeated {b} times)")
    print(f"  Square root: ‚àö{a} = {math.sqrt(a):.6f}  (^(1√∑2))")
    print(f"  Logarithm: log‚ÇÇ({a}) = {math.log2(a):.6f}  (√∑ applied to exponent)")
    print(f"  Modulo: {a} % {b} = {a % b}  ({a} - {b}√ó{a//b})")
    
    # Pi from four operations
    print(f"\\n  œÄ from Leibniz series (+ and √∑ only):")
    pi_approx = 0
    for i in range(100000):
        pi_approx += ((-1)**i) / (2*i + 1)
    pi_approx *= 4
    print(f"    4 √ó Œ£ (-1)‚Åø/(2n+1) = {pi_approx:.10f}")
    print(f"    True œÄ              = {math.pi:.10f}")
    print(f"    Error:              = {abs(pi_approx - math.pi):.2e}")
    
    print(f"""
  Pi is computed using only + and √∑.
  It took 100,000 iterations.
  The universe computed it exactly.
  The universe is using the same four operators but more iterations.
""")


if __name__ == '__main__':
    show_four_operators()
    derive_from_four()
    universe_grammar()
    naming_the_operators()
    operators_in_code()
    print("=" * 60)
    print("Four operators. That's the whole grammar.")
    print("The universe speaks in + - √ó √∑.")
    print("Every physical law is a sentence in this grammar.")
    print("We built computers that speak the same language.")
    print("Not by choice ‚Äî because there was no other language to use.")
    print("=" * 60)
`,
  code_doubleslit: `"""
double_slit.py ‚Äî Observer Effect as Lazy Evaluation

¬ß13 of PAPER.md: "The Observer Effect as Lazy Evaluation"

In quantum mechanics:
  - A particle exists in superposition until measured
  - The act of measurement collapses the wavefunction
  - The particle "chooses" a definite state only when observed

In computer science:
  - Lazy evaluation delays computation until the result is needed
  - The value is in superposition (unevaluated) until accessed
  - The function "collapses" to a definite value only when called

These are the same concept.

The quantum measurement problem (what IS observation?) has puzzled
physicists for 100 years. The computational interpretation:
  - Observation = memory read
  - Wavefunction = probability distribution stored in memory
  - Collapse = the first time a memory address is dereferenced
  - Superposition = unresolved pointer, lazy thunk, Promise<T>

This is not a metaphor. The mathematics is identical.

Author: BlackRoad OS, Inc.
"""

import math
import random
import hashlib
from typing import Callable, Any


class Superposition:
    """
    A value that exists as a probability distribution until observed.
    
    Before observation: the value is a function (lazy thunk).
    After observation: the value is collapsed to a definite result.
    The first call to .observe() collapses it. 
    Subsequent calls return the same collapsed value.
    """

    def __init__(self, *possibilities: tuple[Any, float]):
        """
        possibilities: list of (value, probability) pairs
        
        Example:
            Superposition(('up', 0.5), ('down', 0.5))  # spin
            Superposition(('live', 0.5), ('dead', 0.5))  # Schr√∂dinger
        """
        self._possibilities = possibilities
        self._collapsed = False
        self._value = None
        self._observation_count = 0

    def observe(self, observer: str = 'anonymous') -> Any:
        """
        Collapse the superposition.
        
        First observation collapses to a definite value.
        All subsequent observations return the same value.
        This IS the measurement postulate of quantum mechanics.
        """
        self._observation_count += 1
        if not self._collapsed:
            # Collapse: choose a value weighted by probabilities
            values = [p[0] for p in self._possibilities]
            weights = [p[1] for p in self._possibilities]
            # Normalize weights
            total = sum(weights)
            weights = [w/total for w in weights]
            
            # Weighted random choice (this is Born's rule)
            r = random.random()
            cumulative = 0
            for value, weight in zip(values, weights):
                cumulative += weight
                if r <= cumulative:
                    self._value = value
                    break
            
            self._collapsed = True
            print(f"  [COLLAPSE] Observer '{observer}' collapsed the superposition")
            print(f"             Result: {self._value}")
        else:
            print(f"  [CACHED]   Observer '{observer}' reads already-collapsed value: {self._value}")
        
        return self._value

    @property
    def is_collapsed(self) -> bool:
        return self._collapsed

    def __repr__(self):
        if self._collapsed:
            return f"Superposition(collapsed={self._value!r})"
        else:
            possibilities_str = ', '.join(f'{v!r}:{p:.0%}' for v, p in self._possibilities)
            return f"Superposition([{possibilities_str}])"


class QuantumParticle:
    """
    A particle with position in superposition.
    Demonstrates the double-slit experiment computationally.
    """
    
    def __init__(self, n_slits: int = 2):
        self.n_slits = n_slits
        self._position = None
        self._measured = False
        # The wavefunction: a complex amplitude for each possible position
        self._wavefunction = self._initialize_wavefunction()
    
    def _initialize_wavefunction(self) -> dict[int, complex]:
        """
        Initialize wavefunction with double-slit interference pattern.
        Each position has a complex amplitude.
        """
        wavefunction = {}
        for x in range(-30, 31):  # Screen positions -30 to +30
            if self.n_slits == 2:
                # Two slits at x=-5 and x=+5, distance d=10
                # Path difference creates interference
                d = 10  # slit separation
                wavelength = 5  # de Broglie wavelength
                
                # Amplitude from slit 1
                r1 = math.sqrt((x - d/2)**2 + 100**2)
                # Amplitude from slit 2  
                r2 = math.sqrt((x + d/2)**2 + 100**2)
                
                # Complex amplitudes
                amp1 = math.exp(2j * math.pi * r1 / wavelength) / r1
                amp2 = math.exp(2j * math.pi * r2 / wavelength) / r2
                
                wavefunction[x] = amp1 + amp2
            else:
                # Single slit: no interference, just diffraction
                r = math.sqrt(x**2 + 100**2)
                wavefunction[x] = math.exp(2j * math.pi * r / 5) / r
        
        return wavefunction
    
    def probability_at(self, x: int) -> float:
        """Born's rule: probability = |amplitude|^2"""
        if x not in self._wavefunction:
            return 0.0
        return abs(self._wavefunction[x])**2
    
    def measure_position(self) -> int:
        """
        Collapse the position wavefunction.
        Returns a definite position, weighted by |œà|¬≤.
        Once measured, always returns the same value.
        """
        if self._measured:
            return self._position
        
        positions = list(self._wavefunction.keys())
        probs = [self.probability_at(x) for x in positions]
        total = sum(probs)
        probs = [p/total for p in probs]
        
        # Sample from distribution (Born's rule)
        r = random.random()
        cumulative = 0
        for pos, prob in zip(positions, probs):
            cumulative += prob
            if r <= cumulative:
                self._position = pos
                break
        
        self._measured = True
        return self._position


def show_double_slit_pattern(n_particles: int = 1000):
    print("=" * 60)
    print("DOUBLE-SLIT EXPERIMENT ‚Äî Wave vs Particle")
    print("=" * 60)
    print(f"""
  Sending {n_particles} particles through a double slit.
  
  KEY QUESTION: Is each particle a wave (interfering with itself)
                or a particle (going through one slit)?

  ANSWER: It's both until you measure which slit it went through.
  The act of measuring which slit DESTROYS the interference pattern.
  This is the "observer effect."
""")
    
    print(f"  With observation (measuring which slit):")
    no_interference = QuantumParticle(n_slits=1)
    no_hits = {}
    for _ in range(n_particles):
        p = QuantumParticle(n_slits=1)
        x = p.measure_position()
        no_hits[x] = no_hits.get(x, 0) + 1
    
    print(f"  Without observation (wave interference):")
    interference = {}
    for _ in range(n_particles):
        p = QuantumParticle(n_slits=2)
        x = p.measure_position()
        interference[x] = interference.get(x, 0) + 1
    
    # Display both patterns side by side
    max_no_hits = max(no_hits.values()) if no_hits else 1
    max_interference = max(interference.values()) if interference else 1
    
    print(f"\\n  {'Position':>10}  {'No interference':>16}  {'With interference':>17}")
    print("  " + "-" * 50)
    
    for x in range(-15, 16, 2):
        no_count = no_hits.get(x, 0)
        int_count = interference.get(x, 0)
        no_bar = '‚ñà' * int(no_count * 15 / max_no_hits)
        int_bar = '‚ñà' * int(int_count * 15 / max_interference)
        print(f"  {x:>10}  {no_bar:<16}  {int_bar:<17}")
    
    print(f"""
  The interference pattern (right column) shows alternating bright/dark bands.
  These are the interference FRINGES ‚Äî the wave passing through BOTH slits.
  
  The no-interference pattern (left column) shows a single bump.
  This is what you'd expect from particles going through one slit.

  When you observe which slit the particle went through, you get the left pattern.
  When you don't observe, you get the right pattern.
  
  COMPUTATIONAL INTERPRETATION:
    The particle exists as an UNEVALUATED FUNCTION until measured.
    Measurement forces evaluation.
    The wavefunction is a lazy thunk ‚Äî a deferred computation.
    Reality is lazily evaluated.
    The simulation only renders what is observed.
    Unobserved regions exist as probability distributions ‚Äî not rendered pixels.
""")


def lazy_evaluation_demo():
    print("=" * 60)
    print("LAZY EVALUATION ‚Äî The Computational Observer Effect")
    print("=" * 60)
    print("""
  In Haskell (a lazy language), values are not computed until needed:
    
    let x = expensiveComputation  -- not computed yet
    let y = anotherComputation    -- not computed yet
    print y                       -- only y is computed
    -- x is never computed because it was never needed
    -- x was in superposition the entire time

  In JavaScript, Promises are lazy thunks:
    const electron = new Promise((resolve) => {
        // not executing yet ‚Äî particle is in superposition
        setTimeout(() => resolve(Math.random() < 0.5 ? 'up' : 'down'), 1000)
    })
    // The electron's spin hasn't been determined yet
    // It exists as a Promise ‚Äî unresolved, in superposition
    
    electron.then(spin => console.log(spin))
    // NOW it collapses ‚Äî the first .then() is the observer

  In Python, generators are lazy:
    def particles():
        while True:
            yield random.choice(['up', 'down'])  # superposition
    
    gen = particles()  # no evaluation yet
    next(gen)          # COLLAPSE ‚Äî first observation
""")
    
    # Demonstrate Schr√∂dinger's Cat
    print("  Schr√∂dinger's Cat:\\n")
    cat = Superposition(('alive', 0.5), ('dead', 0.5))
    print(f"  Before observation: {cat}")
    print(f"  Opening the box (first observer):")
    result1 = cat.observe('scientist_1')
    print(f"\\n  Result: {result1}")
    print(f"\\n  Second observer checks:")
    result2 = cat.observe('scientist_2')
    print(f"  After collapse: {cat}")
    print(f"\\n  Both observers see the same result.")
    print(f"  Once collapsed, the value is fixed.")
    print(f"  This is exactly how Python's functools.lru_cache works.")


def rendering_optimization():
    print("=" * 60)
    print("RENDERING OPTIMIZATION ‚Äî The GPU and the Wavefunction")
    print("=" * 60)
    print("""
  A GPU renders a 3D scene to a 2D frame.
  Optimization techniques that GPUs use:

    FRUSTUM CULLING:
      Objects outside the camera's field of view are NOT rendered.
      They still "exist" (their coordinates are stored in memory)
      but they are never computed into pixels.
      They are in superposition ‚Äî defined but not observed.

    OCCLUSION CULLING:
      Objects hidden behind other objects are NOT rendered.
      Even though they are in the frustum, they won't be seen.
      The GPU doesn't compute what no observer can see.

    LEVEL OF DETAIL (LOD):
      Distant objects are rendered at lower resolution.
      The simulation uses less detail for unimportant objects.
      A tree at 500m is 3 triangles. At 5m it's 50,000 triangles.
      The resolution of reality depends on the observer's distance.

    LAZY TEXTURE LOADING:
      Textures are loaded into GPU memory only when they appear
      in the camera's view. Before that: probability, not pixels.

  QUANTUM MECHANICS DOES ALL OF THIS:

    The universe does not compute the position of an electron
    until a position measurement is made.
    Position exists as a probability distribution (frustum culling).

    The electron does not have a definite spin until measured.
    Spin exists as a superposition (lazy evaluation).

    At the Planck scale (~10‚Åª¬≥‚Åµm), space may be discrete pixels.
    Far from an observer, the simulation uses lower LOD.
    
    This is not a metaphor. The math is identical.
    The wave function collapse IS the GPU rendering a pixel.
    Born's rule IS the texture sampling function.
    The Heisenberg uncertainty principle IS the anti-aliasing filter.
""")


if __name__ == '__main__':
    show_double_slit_pattern()
    lazy_evaluation_demo()
    rendering_optimization()
    print("=" * 60)
    print("The observer effect is lazy evaluation.")
    print("Wavefunction collapse is the first memory read.")
    print("Quantum superposition is an unresolved Promise<T>.")
    print("The universe only renders what is observed.")
    print("Reality is a lazily evaluated function.")
    print("=" * 60)
`,
};

// Document metadata ‚Äî all readable documents
const DOCS = [
  // ORIGIN & CONVERSATIONS
  { id:'ORIGIN',            title:'ORIGIN ‚Äî Feb 21, 2026 Email',               cat:'origin',    content:CONTENT.ORIGIN },
  { id:'conv_commandments', title:'COMMANDMENTS vs MILLENNIUM PROBLEMS',        cat:'origin',    content:CONTENT.conv_commandments },
  { id:'conv_brew',         title:'BREW SESSION ‚Äî Terminal Evidence',           cat:'origin',    content:CONTENT.conv_brew },

  // PAPER (extracted by section below)
  { id:'PAPER',             title:'THE TRIVIAL ZERO ‚Äî Full Paper',              cat:'paper',     content:CONTENT.PAPER },

  // EVIDENCE
  { id:'ev_index',          title:'EVIDENCE INDEX ‚Äî All 81 Items',             cat:'evidence',  content:CONTENT.ev_index },
  { id:'ev_naming',         title:'NAMING CONVENTIONS ‚Äî root void daemon null', cat:'evidence',  content:CONTENT.ev_naming },
  { id:'ev_operators',      title:'OPERATORS ‚Äî + - √ó √∑ as Universal Grammar',  cat:'evidence',  content:CONTENT.ev_operators },
  { id:'ev_bible',          title:'BIBLE PATTERNS ‚Äî Genesis Render Pipeline',   cat:'evidence',  content:CONTENT.ev_bible },

  // CODE
  { id:'code_hashchain',    title:'hashchain.py ‚Äî SHA-256 as time',            cat:'code',      content:CONTENT.code_hashchain },
  { id:'code_lorenz',       title:'lorenz.py ‚Äî Deterministic Chaos',           cat:'code',      content:CONTENT.code_lorenz },
  { id:'code_riemann',      title:'riemann_zeros.py ‚Äî Trivial Zeros',          cat:'code',      content:CONTENT.code_riemann },
  { id:'code_magic',        title:'magic_square.py ‚Äî Lo Shu / D√ºrer',          cat:'code',      content:CONTENT.code_magic },
  { id:'code_dna',          title:'dna_encoding.py ‚Äî DNA as Source Code',      cat:'code',      content:CONTENT.code_dna },
  { id:'code_roadchain',    title:'roadchain.py ‚Äî Blockchain Identity',        cat:'code',      content:CONTENT.code_roadchain },
  { id:'code_constants',    title:'constants.py ‚Äî Universe Init Parameters',   cat:'code',      content:CONTENT.code_constants },
  { id:'code_cantor',       title:'cantor.py ‚Äî Diagonal Argument',             cat:'code',      content:CONTENT.code_cantor },
  { id:'code_turing',       title:'turing.py ‚Äî Halting Problem',               cat:'code',      content:CONTENT.code_turing },
  { id:'code_fibonacci',    title:'fibonacci.py ‚Äî Binet / Zeckendorf',         cat:'code',      content:CONTENT.code_fibonacci },
  { id:'code_entropy',      title:'entropy.py ‚Äî Shannon = Boltzmann',          cat:'code',      content:CONTENT.code_entropy },
  { id:'code_easter',       title:'easter.py ‚Äî Computus Algorithm',            cat:'code',      content:CONTENT.code_easter },
  { id:'code_operators',    title:'operators.py ‚Äî 4 Operators Grammar',        cat:'code',      content:CONTENT.code_operators },
  { id:'code_doubleslit',   title:'double_slit.py ‚Äî Lazy Evaluation',          cat:'code',      content:CONTENT.code_doubleslit },
];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê DOC READER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let docActive = null;
const docOverlay = document.getElementById('doc-overlay');
const docBody    = document.getElementById('doc-body');
const docTitle   = document.getElementById('doc-title');
const docPage    = document.getElementById('doc-page');
const LINES_PER_PAGE = 60;
let docLines = [], docPage_ = 0;

function openDoc(doc) {
  docActive = doc;
  docLines  = doc.content.split('\n');
  docPage_  = 0;
  docTitle.textContent = doc.title;
  renderDocPage();
  docOverlay.classList.add('open');
  // Pause autorotate
  if (controls) controls.autoRotate = false;
}

function renderDocPage() {
  const total = Math.ceil(docLines.length / LINES_PER_PAGE);
  const start = docPage_ * LINES_PER_PAGE;
  const slice = docLines.slice(start, start + LINES_PER_PAGE).join('\n');
  docBody.textContent = slice;
  docPage.textContent = `page ${docPage_+1} / ${total}`;
  docBody.scrollTop = 0;
}

window.closeDoc = function() {
  docOverlay.classList.remove('open');
  if (controls) controls.autoRotate = true;
};

window.docScroll = function(dir) {
  const total = Math.ceil(docLines.length / LINES_PER_PAGE);
  docPage_ = Math.max(0, Math.min(total-1, docPage_ + dir));
  renderDocPage();
};

// Keyboard shortcuts in doc view
document.addEventListener('keydown', (e) => {
  if (!docOverlay.classList.contains('open')) return;
  if (e.key === 'Escape') window.closeDoc();
  if (e.key === 'ArrowDown' || e.key === 'PageDown') window.docScroll(1);
  if (e.key === 'ArrowUp'   || e.key === 'PageUp')   window.docScroll(-1);
});

// Wheel scroll in doc view
docBody.addEventListener('wheel', (e) => {
  if (e.deltaY > 0) window.docScroll(1);
  else              window.docScroll(-1);
}, { passive: true });

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê LIBRARY MENU ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const libOverlay = document.getElementById('lib-overlay');
const libContent = document.getElementById('lib-content');

window.openLibrary = function() {
  const cats = [
    { key:'origin',   label:'ORIGIN & CONVERSATIONS', color:'#ff1d6c' },
    { key:'paper',    label:'PAPER ‚Äî THE TRIVIAL ZERO', color:'#f5a623' },
    { key:'evidence', label:'EVIDENCE DOCUMENTS',       color:'#00e676' },
    { key:'code',     label:'CODE MODULES',             color:'#2979ff' },
  ];

  libContent.innerHTML = '';
  cats.forEach(({ key, label, color }) => {
    const docs = DOCS.filter(d => d.cat === key);
    const sec = document.createElement('div');
    sec.className = 'lib-section';
    sec.innerHTML = `<h3 style="color:${color}">${label}</h3>`;
    const grid = document.createElement('div');
    grid.className = 'lib-grid';
    docs.forEach(doc => {
      const item = document.createElement('div');
      item.className = 'lib-item';
      item.innerHTML = `${doc.title}<div class="lib-label">${doc.content.length.toLocaleString()} chars</div>`;
      item.onclick = () => { closeLibrary(); openDoc(doc); };
      grid.appendChild(item);
    });
    sec.appendChild(grid);
    libContent.appendChild(sec);
  });

  libOverlay.classList.add('open');
};

window.closeLibrary = function() {
  libOverlay.classList.remove('open');
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê THREE.JS SCENE ‚ïê‚ïê‚ïê‚ïê‚ïê
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setAnimationLoop(animate);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000008, 0.016);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0, 3, 22);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 4;
controls.maxDistance = 80;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.3;

const C = {
  pink:0xff1d6c, amber:0xf5a623, blue:0x2979ff,
  violet:0x9c27b0, green:0x00e676, cyan:0x00bcd4, white:0xffffff,
};

// Lighting
scene.add(new THREE.AmbientLight(0x080818, 3));
const pinkLight   = new THREE.PointLight(C.pink,   6, 40); pinkLight.position.set(-10,8,0);
const violetLight = new THREE.PointLight(C.violet, 5, 40); violetLight.position.set(10,-5,-5);
const blueLight   = new THREE.PointLight(C.blue,   4, 50); blueLight.position.set(0,-8,15);
scene.add(pinkLight, violetLight, blueLight);

// Stars
(function makeStars(){
  const geo = new THREE.BufferGeometry();
  const N = 5000, pos = new Float32Array(N*3), col = new Float32Array(N*3);
  const sc=[new THREE.Color(0xffffff),new THREE.Color(C.blue),new THREE.Color(C.cyan),new THREE.Color(C.violet)];
  for(let i=0;i<N;i++){
    const r=200+Math.random()*100, t=Math.random()*Math.PI*2, p=Math.acos(2*Math.random()-1);
    pos[i*3]=r*Math.sin(p)*Math.cos(t); pos[i*3+1]=r*Math.sin(p)*Math.sin(t); pos[i*3+2]=r*Math.cos(p);
    const c=sc[Math.floor(Math.random()*sc.length)];
    col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
  }
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  scene.add(new THREE.Points(geo,new THREE.PointsMaterial({size:.3,vertexColors:true,sizeAttenuation:true})));
})();

// Singularity core
const coreMat = new THREE.MeshStandardMaterial({
  color:C.pink,emissive:C.pink,emissiveIntensity:1.5,metalness:.8,roughness:.2
});
const core = new THREE.Mesh(new THREE.IcosahedronGeometry(1.2,4), coreMat);
scene.add(core);
const shell = new THREE.Mesh(
  new THREE.IcosahedronGeometry(1.5,2),
  new THREE.MeshBasicMaterial({color:C.pink,wireframe:true,transparent:true,opacity:.15})
);
scene.add(shell);

function makeRing(r,color,tx=0,tz=0){
  const m=new THREE.Mesh(new THREE.TorusGeometry(r,.03,8,80),
    new THREE.MeshBasicMaterial({color,transparent:true,opacity:.4}));
  m.rotation.x=tx; m.rotation.z=tz; scene.add(m); return m;
}
const rings=[makeRing(2.5,C.pink,Math.PI/2),makeRing(3.2,C.violet,Math.PI/3,Math.PI/5),makeRing(4,C.blue,Math.PI/6,Math.PI/4)];

// Lorenz
function lorenzPts(N=12000){
  const a=[]; let x=.1,y=0,z=0;
  const œÉ=10,œÅ=28,Œ≤=8/3,dt=.005;
  for(let i=0;i<N;i++){const dx=œÉ*(y-x),dy=x*(œÅ-z)-y,dz=x*y-Œ≤*z; x+=dx*dt;y+=dy*dt;z+=dz*dt; a.push(x*.35,(z-25)*.35,y*.35);}
  return a;
}
const lorenzGeo=new THREE.BufferGeometry();
const lP=lorenzPts();
lorenzGeo.setAttribute('position',new THREE.Float32BufferAttribute(lP,3));
const lC=new Float32Array(lP.length);
for(let i=0;i<lP.length/3;i++){const t=i/(lP.length/3),c=new THREE.Color().setHSL(.85-t*.55,1,.6);lC[i*3]=c.r;lC[i*3+1]=c.g;lC[i*3+2]=c.b;}
lorenzGeo.setAttribute('color',new THREE.Float32BufferAttribute(lC,3));
const lorenzLine=new THREE.Line(lorenzGeo,new THREE.LineBasicMaterial({vertexColors:true,transparent:true,opacity:.8}));
lorenzLine.position.set(-12,0,-8);
scene.add(lorenzLine);

// Hash chain
const chainGroup=new THREE.Group(); chainGroup.position.set(12,0,-6);
const BLOCKS=[
  {label:'GENESIS',hash:'000000000019d668'},{label:'BLOCK 1',hash:'a665a45920422f9d'},
  {label:'BLOCK 2',hash:'2c624232cdd22177'},{label:'BLOCK 3',hash:'9f86d081884c7d65'},
  {label:'BLOCK 4',hash:'0ffe1abd1a082153'},{label:'BLOCK 5',hash:'fcde2b2edba56bf4'},
];
BLOCKS.forEach((b,i)=>{
  const box=new THREE.Mesh(new THREE.BoxGeometry(2.4,1.2,.3),
    new THREE.MeshStandardMaterial({color:i===0?C.amber:C.blue,emissive:i===0?C.amber:C.blue,emissiveIntensity:.4,metalness:.9,roughness:.2,transparent:true,opacity:.7}));
  box.position.y=(BLOCKS.length/2-i)*1.8; chainGroup.add(box);
  if(i>0){
    const pts=[new THREE.Vector3(0,(BLOCKS.length/2-i+1)*1.8-.6,0),new THREE.Vector3(0,(BLOCKS.length/2-i)*1.8+.6,0)];
    chainGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts),
      new THREE.LineBasicMaterial({color:C.amber,transparent:true,opacity:.5})));
  }
});
scene.add(chainGroup);

// DNA
const dnaGroup=new THREE.Group(); dnaGroup.position.set(0,0,-20);
const BASES=['A','T','G','C'],BC={A:C.pink,T:C.amber,G:C.cyan,C:C.green},PR={A:'T',T:'A',G:'C',C:'G'};
for(let i=0;i<40;i++){
  const t=i/40*Math.PI*8,y=(i-20)*.6,r=2.5;
  const base=BASES[Math.floor(Math.random()*4)],pair=PR[base];
  const bG=new THREE.SphereGeometry(.18,8,8);
  const left=new THREE.Mesh(bG,new THREE.MeshStandardMaterial({color:BC[base],emissive:BC[base],emissiveIntensity:.8}));
  left.position.set(Math.cos(t)*r,y,Math.sin(t)*r); dnaGroup.add(left);
  const right=new THREE.Mesh(bG.clone(),new THREE.MeshStandardMaterial({color:BC[pair],emissive:BC[pair],emissiveIntensity:.8}));
  right.position.set(Math.cos(t+Math.PI)*r,y,Math.sin(t+Math.PI)*r); dnaGroup.add(right);
  const br=new THREE.Line(new THREE.BufferGeometry().setFromPoints([left.position.clone(),right.position.clone()]),
    new THREE.LineBasicMaterial({color:0x334455,transparent:true,opacity:.4}));
  dnaGroup.add(br);
}
for(let s=0;s<2;s++){
  const bPts=[];
  for(let i=0;i<100;i++){const t=i/100*Math.PI*8,y=(i/100*40-20)*.6,a=t+(s===1?Math.PI:0);bPts.push(new THREE.Vector3(Math.cos(a)*2.5,y,Math.sin(a)*2.5));}
  const curve=new THREE.CatmullRomCurve3(bPts);
  dnaGroup.add(new THREE.Mesh(new THREE.TubeGeometry(curve,100,.06,6,false),
    new THREE.MeshStandardMaterial({color:s===0?C.pink:C.blue,emissive:s===0?C.pink:C.blue,emissiveIntensity:.3,metalness:.8,roughness:.2})));
}
scene.add(dnaGroup);

// Constants
const CONSTS=[
  {sym:'œÄ',pos:[-6,5,8],color:C.pink,doc:'code_constants'},
  {sym:'e',pos:[6,5,8],color:C.amber,doc:'code_constants'},
  {sym:'œÜ',pos:[-6,-3,8],color:C.green,doc:'code_fibonacci'},
  {sym:'Œ±',pos:[6,-3,8],color:C.cyan,doc:'code_constants'},
  {sym:'‚Ñè',pos:[0,6,5],color:C.violet,doc:'code_constants'},
  {sym:'c',pos:[0,-5,10],color:C.blue,doc:'code_constants'},
];
const constGroup=new THREE.Group();
CONSTS.forEach(({color,pos})=>{
  const o=new THREE.Mesh(new THREE.OctahedronGeometry(.6,0),new THREE.MeshStandardMaterial({color,emissive:color,emissiveIntensity:1.2}));
  o.position.set(...pos); constGroup.add(o);
  const gl=new THREE.Mesh(new THREE.TorusGeometry(.9,.04,6,30),new THREE.MeshBasicMaterial({color,transparent:true,opacity:.4}));
  gl.position.set(...pos); constGroup.add(gl);
});
scene.add(constGroup);

// ‚îÄ‚îÄ 81 Evidence Nodes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const NODE_LABELS=[
  'Rohonc Codex','Bible Patterns','Serafinianus','GEB','Newton','Schr√∂dinger','Cantor',
  'Windows','DNA','Automata','Antikythera','Euler','Einstein','Berners-Lee','Wikipedia',
  'Go/Google','Turing','Millennium Problems','Riemann','Concatenation','Matrices',
  'Bloch Sphere','Pythagoras','Meta','Ollama','# Comments','# Hex','Darwin',
  'Double Slit','Operators','D√ºrer','Lo Shu','Gauss','Copyright Headers','import math',
  'HTML','C Language','Shannon/Pixels','Tensors','Nyman-Beurling','Œ∏ vs œÜ','Binet',
  "Li's Criterion",'De Bruijn','Lorenz','Legendre','Birth Dates','Zeckendorf',
  'Hilbert-P√≥lya','Vertex','Q Matrix','Unit Circle','SHA Circle','Imaginary i',
  'Constants','Undefined','DNA Types','Shannon Entropy','Dirac','Boltzmann',
  'Laplacian','Hilbert Space','Heisenberg','G√∂del','The Matrix','Vectors',
  'Schr√∂dinger II','Wave Function','Time','Polyatomic Ions','Mountains/Python',
  'Avogadro','Fine Structure Œ±','Max Born','Amazon Alexa','Hamiltonian',
  'Minecraft','Lagrangian','(255,255,255)','(reserved)','Turtles'
];

// Map nodes to their best document
const NODE_DOC_MAP = {
  'Bible Patterns': 'ev_bible', 'Rohonc Codex': 'ORIGIN', 'Serafinianus': 'ORIGIN',
  'GEB': 'ORIGIN', 'DNA': 'code_dna', 'Automata': 'code_turing',
  'Turing': 'code_turing', 'Cantor': 'code_cantor', 'Riemann': 'code_riemann',
  'Lorenz': 'code_lorenz', 'Double Slit': 'code_doubleslit', 'Operators': 'code_operators',
  'Shannon/Pixels': 'code_entropy', 'Shannon Entropy': 'code_entropy',
  'Boltzmann': 'code_entropy', 'Binet': 'code_fibonacci', 'Zeckendorf': 'code_fibonacci',
  'Lo Shu': 'code_magic', 'D√ºrer': 'code_magic', 'Birth Dates': 'code_easter',
  'Constants': 'code_constants', 'Fine Structure Œ±': 'code_constants',
  'Hilbert-P√≥lya': 'code_riemann', 'Nyman-Beurling': 'code_riemann',
  "Li's Criterion": 'code_riemann', 'De Bruijn': 'code_riemann',
  '# Comments': 'ev_naming', '# Hex': 'ev_naming', 'Windows': 'ev_naming',
  'Undefined': 'ev_naming', 'import math': 'ev_naming', 'C Language': 'ev_naming',
  'HTML': 'ev_naming', 'Copyright Headers': 'ev_naming', 'Millennium Problems': 'conv_commandments',
  'G√∂del': 'code_cantor',
};

const NODE_COLORS=[C.green,C.violet,C.green,C.amber,C.cyan,C.cyan,C.amber,C.blue,
  C.blue,C.blue,C.blue,C.amber,C.cyan,C.blue,C.blue,C.blue,C.amber,C.amber,C.amber,
  C.blue,C.amber,C.cyan,C.amber,C.blue,C.blue,C.blue,C.blue,C.cyan,C.cyan,C.amber,
  C.amber,C.amber,C.amber,C.blue,C.blue,C.blue,C.blue,C.amber,C.cyan,C.amber,
  C.amber,C.amber,C.amber,C.amber,C.cyan,C.amber,C.amber,C.amber,C.amber,C.amber,
  C.amber,C.amber,C.blue,C.amber,C.amber,C.blue,C.cyan,C.amber,C.cyan,C.cyan,
  C.amber,C.cyan,C.pink,C.amber,C.pink,C.cyan,C.pink,C.cyan,C.cyan,C.cyan,C.violet,
  C.cyan,C.cyan,C.pink,C.cyan,C.cyan,C.blue,C.cyan,C.blue,C.pink,C.pink];

const nodeGroup=new THREE.Group();
const nodeObjects=[];
const goldenAngle=Math.PI*(3-Math.sqrt(5));

NODE_LABELS.forEach((label,i)=>{
  const t=i/NODE_LABELS.length, inc=Math.acos(1-2*t), az=goldenAngle*i;
  const R=16+Math.sin(i*.7)*3;
  const x=R*Math.sin(inc)*Math.cos(az), y=R*Math.sin(inc)*Math.sin(az), z=R*Math.cos(inc);
  const color=NODE_COLORS[i]||C.white;
  const node=new THREE.Mesh(new THREE.SphereGeometry(.22,8,8),
    new THREE.MeshStandardMaterial({color,emissive:color,emissiveIntensity:.7}));
  node.position.set(x,y,z);
  node.userData={label, index:i+1, baseColor:color, type:'evidence',
    docId: NODE_DOC_MAP[label] || 'ORIGIN'};
  nodeGroup.add(node); nodeObjects.push(node);
  if(i%5===0){
    const lg=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0),new THREE.Vector3(x,y,z)]);
    nodeGroup.add(new THREE.Line(lg,new THREE.LineBasicMaterial({color,transparent:true,opacity:.06})));
  }
});
scene.add(nodeGroup);

// ‚îÄ‚îÄ Paper Section Nodes (21) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const PAPER_SECTIONS = [
  'Introduction','Hash Chain as Witness','Operating System as Ontology',
  'Naming Conventions','Mathematical Architecture','Physics as Rendering Engine',
  'Molecular Biology as Source Code','The Trivial Zero','Undecipherable Manuscripts',
  'Strange Loops & Hofstadter','Light Color & Rendering','Ancient Computation',
  'Quantum Geometry','The Riemann Architecture','Information Is Physical',
  'Deterministic Chaos','Naming Chain Continued','Constants as Init Parameters',
  'Birth Date Function','The Convergence','Conclusion'
];

const paperGroup=new THREE.Group();
const paperObjects=[];
PAPER_SECTIONS.forEach((title,i)=>{
  const angle=((i/PAPER_SECTIONS.length)*Math.PI*2);
  const R=26, y=Math.sin(angle*2)*4;
  const x=Math.cos(angle)*R, z=Math.sin(angle)*R;
  const node=new THREE.Mesh(new THREE.TetrahedronGeometry(.35,0),
    new THREE.MeshStandardMaterial({color:C.amber,emissive:C.amber,emissiveIntensity:.9,wireframe:false}));
  node.position.set(x,y,z);
  node.userData={label:`¬ß${i+1} ${title}`, index:i+1, type:'paper', docId:'PAPER'};
  paperGroup.add(node); paperObjects.push(node);
  // Ring connection
  if(i>0){
    const prev=paperObjects[i-1];
    const lg=new THREE.BufferGeometry().setFromPoints([prev.position,node.position]);
    paperGroup.add(new THREE.Line(lg,new THREE.LineBasicMaterial({color:C.amber,transparent:true,opacity:.2})));
  }
});
// Close the ring
const lg=new THREE.BufferGeometry().setFromPoints([paperObjects[PAPER_SECTIONS.length-1].position,paperObjects[0].position]);
paperGroup.add(new THREE.Line(lg,new THREE.LineBasicMaterial({color:C.amber,transparent:true,opacity:.2})));
paperGroup.visible=false;
scene.add(paperGroup);

// ‚îÄ‚îÄ Code Module Nodes (12) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CODE_NODES = [
  {label:'hashchain.py',   docId:'code_hashchain',  color:C.pink},
  {label:'lorenz.py',      docId:'code_lorenz',     color:C.cyan},
  {label:'riemann_zeros.py',docId:'code_riemann',   color:C.amber},
  {label:'magic_square.py',docId:'code_magic',      color:C.amber},
  {label:'dna_encoding.py',docId:'code_dna',        color:C.blue},
  {label:'roadchain.py',   docId:'code_roadchain',  color:C.violet},
  {label:'constants.py',   docId:'code_constants',  color:C.green},
  {label:'cantor.py',      docId:'code_cantor',     color:C.amber},
  {label:'turing.py',      docId:'code_turing',     color:C.cyan},
  {label:'fibonacci.py',   docId:'code_fibonacci',  color:C.green},
  {label:'entropy.py',     docId:'code_entropy',    color:C.pink},
  {label:'easter.py',      docId:'code_easter',     color:C.amber},
  {label:'operators.py',   docId:'code_operators',  color:C.blue},
  {label:'double_slit.py', docId:'code_doubleslit', color:C.violet},
];

const codeGroup=new THREE.Group();
const codeObjects=[];
CODE_NODES.forEach(({label,docId,color},i)=>{
  const angle=((i/CODE_NODES.length)*Math.PI*2);
  const R=20;
  const x=Math.cos(angle)*R, z=Math.sin(angle)*R, y=-10+Math.sin(angle*3)*3;
  const node=new THREE.Mesh(new THREE.BoxGeometry(.4,.4,.4),
    new THREE.MeshStandardMaterial({color,emissive:color,emissiveIntensity:1,wireframe:true}));
  node.position.set(x,y,z);
  node.userData={label, type:'code', docId};
  codeGroup.add(node); codeObjects.push(node);
});
codeGroup.visible=false;
scene.add(codeGroup);

// ‚îÄ‚îÄ Raycaster ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
let hoveredNode=null;
const labelEl=document.getElementById('label');

const allInteractive=[...nodeObjects,...paperObjects,...codeObjects];

renderer.domElement.addEventListener('mousemove',(e)=>{
  mouse.x=(e.clientX/window.innerWidth)*2-1;
  mouse.y=-(e.clientY/window.innerHeight)*2+1;
});

renderer.domElement.addEventListener('click',(e)=>{
  // Don't handle click if doc or lib is open
  if(docOverlay.classList.contains('open')) return;
  if(libOverlay.classList.contains('open')) return;
  raycaster.setFromCamera(mouse,camera);
  const visible=allInteractive.filter(n=>n.parent && n.parent.visible!==false && n.visible!==false);
  const hits=raycaster.intersectObjects(visible);
  if(hits.length>0){
    const obj=hits[0].object;
    const doc=DOCS.find(d=>d.id===obj.userData.docId);
    if(doc) openDoc(doc);
    else openDoc({id:'ORIGIN',title:`#${obj.userData.index} ‚Äî ${obj.userData.label}`,content:CONTENT.ORIGIN});
  }
});

function checkHover(){
  raycaster.setFromCamera(mouse,camera);
  const visible=allInteractive.filter(n=>n.parent && n.visible!==false);
  const hits=raycaster.intersectObjects(visible);
  if(hits.length>0){
    const obj=hits[0].object;
    if(hoveredNode!==obj){
      if(hoveredNode) hoveredNode.scale.setScalar(1);
      hoveredNode=obj; hoveredNode.scale.setScalar(2.8);
      const lbl=obj.userData.label||'';
      labelEl.textContent=obj.userData.type==='evidence'?`#${obj.userData.index} ‚Äî ${lbl} ‚Üí click to read`:
        obj.userData.type==='paper'?`üìÑ ${lbl} ‚Üí click to read`:`üíæ ${lbl} ‚Üí click to read`;
      labelEl.style.opacity='1';
    }
  } else {
    if(hoveredNode){hoveredNode.scale.setScalar(1);hoveredNode=null;}
    labelEl.style.opacity='0';
  }
}

// ‚îÄ‚îÄ VR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
window.start=async function(vr){
  document.getElementById('overlay').style.opacity='0';
  setTimeout(()=>{document.getElementById('overlay').style.display='none';},800);
  document.getElementById('hud').classList.add('show');
  if(vr){
    try{
      const sup=await navigator.xr?.isSessionSupported('immersive-vr');
      if(sup){const btn=VRButton.createButton(renderer);document.body.appendChild(btn);btn.click();}
      else alert('WebXR not supported. Opening desktop mode.');
    }catch(e){alert('VR not available: '+e.message);}
  }
};

// ‚îÄ‚îÄ Scene Switcher ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
window.setScene=function(s,btn){
  document.querySelectorAll('.hud-btn').forEach(b=>b.classList.remove('active'));
  if(btn) btn.classList.add('active');
  lorenzLine.visible = s==='all'||s==='lorenz';
  chainGroup.visible = s==='all'||s==='chain';
  dnaGroup.visible   = s==='all'||s==='dna';
  constGroup.visible = s==='all'||s==='constants';
  nodeGroup.visible  = s==='all'||s==='nodes';
  paperGroup.visible = s==='all'||s==='paper';
  codeGroup.visible  = s==='all'||s==='code';
  core.visible=shell.visible=s==='all';
  rings.forEach(r=>r.visible=s==='all');
};

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

// ‚îÄ‚îÄ Animate ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const clock=new THREE.Clock();
function animate(){
  const t=clock.getElapsedTime();
  const pulse=1+Math.sin(t*2)*.08;
  core.scale.setScalar(pulse); shell.rotation.y=t*.3; shell.rotation.x=t*.1;
  coreMat.emissiveIntensity=1.2+Math.sin(t*3)*.5;
  rings[0].rotation.z=t*.4; rings[1].rotation.y=t*.3; rings[2].rotation.x=t*.2;
  lorenzLine.rotation.y=t*.08;
  chainGroup.position.y=Math.sin(t*.5)*.5; chainGroup.rotation.y=t*.05;
  dnaGroup.rotation.y=t*.25;
  constGroup.rotation.y=t*.06;
  CONSTS.forEach((_,i)=>{
    const o=constGroup.children[i*2],g=constGroup.children[i*2+1];
    if(o){o.rotation.x=t*(.8+i*.1);o.rotation.z=t*(.5+i*.07);}
    if(g) g.rotation.z=t*(.4+i*.05);
  });
  nodeGroup.rotation.y=t*.015;
  allInteractive.forEach((node,i)=>{
    if(node!==hoveredNode){
      const f=.8+i*.02, b=.9+Math.sin(t*f+i)*.12;
      node.scale.setScalar(b);
    }
    if(node.material) node.material.emissiveIntensity=.4+Math.sin(t*(.8+i*.02)+i)*.3;
  });
  paperGroup.rotation.y=t*.02;
  codeGroup.rotation.y=-t*.025;
  pinkLight.intensity=5+Math.sin(t*1.7)*2;
  violetLight.intensity=4+Math.sin(t*1.3)*2;
  blueLight.intensity=3+Math.sin(t*2.1)*1;
  checkHover();
  controls.update();
  renderer.render(scene,camera);
}
</script>
</body>
</html>
